!(function () {
  "use strict"
  let e =
    ((n = document.createElement("a")),
    document.body.appendChild(n),
    (n.style = "display: none"),
    function (e, t) {
      let a = window.URL.createObjectURL(e)
      ;(n.href = a), (n.download = t), n.click(), window.URL.revokeObjectURL(a)
    })
  var n
  function t(e, n, t) {
    return e < n && (e = n), e > t && (e = t), e
  }
  function a(e, n, a, o, r, i = !1) {
    let s = o + ((r - o) * (e - n)) / (a - n)
    return i && (s = t(s, o, r)), s
  }
  function o() {
    return new Proxy(new URLSearchParams(window.location.search), {
      get: (e, n) => e.get(n),
    })
  }
  let r = {}
  function i(e) {
    let n = performance.now()
    r[e] = n
  }
  function s(e) {
    if (!r[e])
      throw new Error(
        "Benchmark with name '" +
          e +
          "' does not have a start time. Please call benchmarkFrom(name) before calling benchmarkTo"
      )
    performance.now()
  }
  class l {
    constructor(e, n, t) {
      ;(this.variables = []), (this.currentTextureIndex = 0)
      let a = THREE.FloatType
      const o = new THREE.Scene(),
        r = new THREE.Camera()
      r.position.z = 1
      const i = { passThruTexture: { value: null } },
        s = u(
          "uniform sampler2D passThruTexture;\n\nvoid main() {\n\n vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n  gl_FragColor = texture2D( passThruTexture, uv );\n\n}\n",
          i
        ),
        l = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), s)
      function c(t) {
        t.defines.resolution =
          "vec2( " + e.toFixed(1) + ", " + n.toFixed(1) + " )"
      }
      function u(e, n) {
        n = n || {}
        const t = new THREE.ShaderMaterial({
          uniforms: n,
          vertexShader:
            "void main() {\n\n gl_Position = vec4( position, 1.0 );\n\n}\n",
          fragmentShader: e,
        })
        return c(t), t
      }
      o.add(l),
        (this.setDataType = function (e) {
          return (a = e), this
        }),
        (this.addVariable = function (e, n, t) {
          const a = {
            name: e,
            initialValueTexture: t,
            material: this.createShaderMaterial(n),
            dependencies: null,
            renderTargets: [],
            wrapS: null,
            wrapT: null,
            minFilter: THREE.NearestFilter,
            magFilter: THREE.NearestFilter,
          }
          return this.variables.push(a), a
        }),
        (this.setVariableDependencies = function (e, n) {
          e.dependencies = n
        }),
        (this.init = function () {
          if (
            !1 === t.capabilities.isWebGL2 &&
            !1 === t.extensions.has("OES_texture_float")
          )
            return "No OES_texture_float support for float textures."
          if (0 === t.capabilities.maxVertexTextures)
            return "No support for vertex shader textures."
          for (let t = 0; t < this.variables.length; t++) {
            const a = this.variables[t]
            ;(a.renderTargets[0] = this.createRenderTarget(
              e,
              n,
              a.wrapS,
              a.wrapT,
              a.minFilter,
              a.magFilter
            )),
              (a.renderTargets[1] = this.createRenderTarget(
                e,
                n,
                a.wrapS,
                a.wrapT,
                a.minFilter,
                a.magFilter
              )),
              this.renderTexture(a.initialValueTexture, a.renderTargets[0]),
              this.renderTexture(a.initialValueTexture, a.renderTargets[1])
            const o = a.material,
              r = o.uniforms
            if (null !== a.dependencies)
              for (let e = 0; e < a.dependencies.length; e++) {
                const n = a.dependencies[e]
                if (n.name !== a.name) {
                  let e = !1
                  for (let t = 0; t < this.variables.length; t++)
                    if (n.name === this.variables[t].name) {
                      e = !0
                      break
                    }
                  if (!e)
                    return (
                      "Variable dependency not found. Variable=" +
                      a.name +
                      ", dependency=" +
                      n.name
                    )
                }
                ;(r[n.name] = { value: null }),
                  (o.fragmentShader =
                    "\nuniform sampler2D " + n.name + ";\n" + o.fragmentShader)
              }
          }
          return (this.currentTextureIndex = 0), null
        }),
        (this.compute = function () {
          const e = this.currentTextureIndex,
            n = 0 === this.currentTextureIndex ? 1 : 0
          for (let t = 0, a = this.variables.length; t < a; t++) {
            const a = this.variables[t]
            if (null !== a.dependencies) {
              const n = a.material.uniforms
              for (let t = 0, o = a.dependencies.length; t < o; t++) {
                const o = a.dependencies[t]
                n[o.name].value = o.renderTargets[e].texture
              }
            }
            this.doRenderTarget(a.material, a.renderTargets[n])
          }
          this.currentTextureIndex = n
        }),
        (this.getCurrentRenderTarget = function (e) {
          return e.renderTargets[this.currentTextureIndex]
        }),
        (this.getAlternateRenderTarget = function (e) {
          return e.renderTargets[0 === this.currentTextureIndex ? 1 : 0]
        }),
        (this.addResolutionDefine = c),
        (this.createShaderMaterial = u),
        (this.createRenderTarget = function (t, o, r, i, s, l) {
          ;(t = t || e),
            (o = o || n),
            (r = r || THREE.ClampToEdgeWrapping),
            (i = i || THREE.ClampToEdgeWrapping),
            (s = s || THREE.NearestFilter),
            (l = l || THREE.NearestFilter)
          return new THREE.WebGLRenderTarget(t, o, {
            wrapS: r,
            wrapT: i,
            minFilter: s,
            magFilter: l,
            format: THREE.RGBAFormat,
            type: a,
            depthBuffer: !1,
          })
        }),
        (this.createTexture = function () {
          const t = new Float32Array(e * n * 4)
          return new THREE.DataTexture(
            t,
            e,
            n,
            THREE.RGBAFormat,
            THREE.FloatType
          )
        }),
        (this.renderTexture = function (e, n) {
          ;(i.passThruTexture.value = e),
            this.doRenderTarget(s, n),
            (i.passThruTexture.value = null)
        }),
        (this.doRenderTarget = function (e, n) {
          const a = t.getRenderTarget()
          ;(l.material = e),
            t.setRenderTarget(n),
            t.render(o, r),
            (l.material = s),
            t.setRenderTarget(a)
        })
    }
  }
  var c = THREE
  let u =
    "\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nfloat cnoise(vec3 P){\nvec3 Pi0 = floor(P);\nvec3 Pi1 = Pi0 + vec3(1.0);\nPi0 = mod(Pi0, 289.0);\nPi1 = mod(Pi1, 289.0);\nvec3 Pf0 = fract(P);\nvec3 Pf1 = Pf0 - vec3(1.0);\nvec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\nvec4 iy = vec4(Pi0.yy, Pi1.yy);\nvec4 iz0 = Pi0.zzzz;\nvec4 iz1 = Pi1.zzzz;\nvec4 ixy = permute(permute(ix) + iy);\nvec4 ixy0 = permute(ixy + iz0);\nvec4 ixy1 = permute(ixy + iz1);\nvec4 gx0 = ixy0 / 7.0;\nvec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\ngx0 = fract(gx0);\nvec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\nvec4 sz0 = step(gz0, vec4(0.0));\ngx0 -= sz0 * (step(0.0, gx0) - 0.5);\ngy0 -= sz0 * (step(0.0, gy0) - 0.5);\nvec4 gx1 = ixy1 / 7.0;\nvec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\ngx1 = fract(gx1);\nvec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\nvec4 sz1 = step(gz1, vec4(0.0));\ngx1 -= sz1 * (step(0.0, gx1) - 0.5);\ngy1 -= sz1 * (step(0.0, gy1) - 0.5);\nvec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\nvec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\nvec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\nvec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\nvec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\nvec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\nvec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\nvec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\nvec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\ng000 *= norm0.x;\ng010 *= norm0.y;\ng100 *= norm0.z;\ng110 *= norm0.w;\nvec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\ng001 *= norm1.x;\ng011 *= norm1.y;\ng101 *= norm1.z;\ng111 *= norm1.w;\nfloat n000 = dot(g000, Pf0);\nfloat n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\nfloat n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\nfloat n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\nfloat n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\nfloat n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\nfloat n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\nfloat n111 = dot(g111, Pf1);\nvec3 fade_xyz = fade(Pf0);\nvec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\nvec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\nfloat n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \nreturn 2.2 * n_xyz;\n}"
  u =
    "\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec4 fade(vec4 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nfloat cnoise(vec3 P2){\nvec4 P = vec4(P2 * 1.28, 0.0);\nvec4 Pi0 = floor(P);\nvec4 Pi1 = Pi0 + 1.0;\nPi0 = mod(Pi0, 289.0);\nPi1 = mod(Pi1, 289.0);\nvec4 Pf0 = fract(P);\nvec4 Pf1 = Pf0 - 1.0;\nvec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\nvec4 iy = vec4(Pi0.yy, Pi1.yy);\nvec4 iz0 = vec4(Pi0.zzzz);\nvec4 iz1 = vec4(Pi1.zzzz);\nvec4 iw0 = vec4(Pi0.wwww);\nvec4 iw1 = vec4(Pi1.wwww);\nvec4 ixy = permute(permute(ix) + iy);\nvec4 ixy0 = permute(ixy + iz0);\nvec4 ixy1 = permute(ixy + iz1);\nvec4 ixy00 = permute(ixy0 + iw0);\nvec4 ixy01 = permute(ixy0 + iw1);\nvec4 ixy10 = permute(ixy1 + iw0);\nvec4 ixy11 = permute(ixy1 + iw1);\nvec4 gx00 = ixy00 / 7.0;\nvec4 gy00 = floor(gx00) / 7.0;\nvec4 gz00 = floor(gy00) / 6.0;\ngx00 = fract(gx00) - 0.5;\ngy00 = fract(gy00) - 0.5;\ngz00 = fract(gz00) - 0.5;\nvec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\nvec4 sw00 = step(gw00, vec4(0.0));\ngx00 -= sw00 * (step(0.0, gx00) - 0.5);\ngy00 -= sw00 * (step(0.0, gy00) - 0.5);\nvec4 gx01 = ixy01 / 7.0;\nvec4 gy01 = floor(gx01) / 7.0;\nvec4 gz01 = floor(gy01) / 6.0;\ngx01 = fract(gx01) - 0.5;\ngy01 = fract(gy01) - 0.5;\ngz01 = fract(gz01) - 0.5;\nvec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\nvec4 sw01 = step(gw01, vec4(0.0));\ngx01 -= sw01 * (step(0.0, gx01) - 0.5);\ngy01 -= sw01 * (step(0.0, gy01) - 0.5);\nvec4 gx10 = ixy10 / 7.0;\nvec4 gy10 = floor(gx10) / 7.0;\nvec4 gz10 = floor(gy10) / 6.0;\ngx10 = fract(gx10) - 0.5;\ngy10 = fract(gy10) - 0.5;\ngz10 = fract(gz10) - 0.5;\nvec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\nvec4 sw10 = step(gw10, vec4(0.0));\ngx10 -= sw10 * (step(0.0, gx10) - 0.5);\ngy10 -= sw10 * (step(0.0, gy10) - 0.5);\nvec4 gx11 = ixy11 / 7.0;\nvec4 gy11 = floor(gx11) / 7.0;\nvec4 gz11 = floor(gy11) / 6.0;\ngx11 = fract(gx11) - 0.5;\ngy11 = fract(gy11) - 0.5;\ngz11 = fract(gz11) - 0.5;\nvec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\nvec4 sw11 = step(gw11, vec4(0.0));\ngx11 -= sw11 * (step(0.0, gx11) - 0.5);\ngy11 -= sw11 * (step(0.0, gy11) - 0.5);\nvec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\nvec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\nvec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\nvec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\nvec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\nvec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\nvec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\nvec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\nvec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\nvec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\nvec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\nvec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\nvec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\nvec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\nvec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\nvec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\nvec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\ng0000 *= norm00.x;\ng0100 *= norm00.y;\ng1000 *= norm00.z;\ng1100 *= norm00.w;\nvec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\ng0001 *= norm01.x;\ng0101 *= norm01.y;\ng1001 *= norm01.z;\ng1101 *= norm01.w;\nvec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\ng0010 *= norm10.x;\ng0110 *= norm10.y;\ng1010 *= norm10.z;\ng1110 *= norm10.w;\nvec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\ng0011 *= norm11.x;\ng0111 *= norm11.y;\ng1011 *= norm11.z;\ng1111 *= norm11.w;\nfloat n0000 = dot(g0000, Pf0);\nfloat n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\nfloat n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\nfloat n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\nfloat n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\nfloat n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\nfloat n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\nfloat n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\nfloat n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\nfloat n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\nfloat n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\nfloat n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\nfloat n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\nfloat n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\nfloat n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\nfloat n1111 = dot(g1111, Pf1);\nvec4 fade_xyzw = fade(Pf0);\nvec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\nvec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\nvec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\nvec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\nfloat n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\nreturn 2.2 * n_xyzw * .7;\n}"
  let m =
      "\nfloat fbm(vec3 x, int numOctaves) {\nfloat v = 0.0;\nfloat a = 0.5;\nvec3 shift = vec3(100);\nfor (int i = 0; i < numOctaves; ++i) {\nv += a * cnoise(x);\nx = x * 2.0 + shift;\na *= 0.5;\n}\nreturn v;\n}\n",
    d =
      "\nfloat hash12(vec2 p)\n{\nvec3 p3  = fract(vec3(p.xyx) * .1031);\np3 += dot(p3, p3.yzx + 33.33);\nreturn fract((p3.x + p3.y) * p3.z);\n}\n",
    f = "#define PI 3.1415926538",
    p =
      "\nmat4 rotationMatrix(vec3 axis, float angle)\n{\naxis = normalize(axis);\nfloat s = sin(angle);\nfloat c = cos(angle);\nfloat oc = 1.0 - c;\nreturn mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\noc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\noc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n0.0,                                0.0,                                0.0,                                1.0);\n}\n",
    v =
      "\nvec2 uvFromIndex (int i, ivec2 s)\n{\nfloat y = floor(float(i) / float(s.x));\nfloat x = float(i) - (y * float(s.x));\nvec2 uv = vec2(x, y) / vec2(s);\nreturn uv;\n}\n",
    g =
      "\nvec4 texture2DAtIndex (sampler2D tex, int i, ivec2 s)\n{\nvec2 uv = uvFromIndex(i, s);\nreturn texture2D(tex, uv);\n}\n"
  var h = {
      d: (e, n) => {
        for (var t in n)
          h.o(n, t) &&
            !h.o(e, t) &&
            Object.defineProperty(e, t, { enumerable: !0, get: n[t] })
      },
      o: (e, n) => Object.prototype.hasOwnProperty.call(e, n),
    },
    x = {}
  h.d(x, { L: () => z, x: () => b })
  const y = (
      new Function("try {return this===window;}catch(e){ return false;}")()
        ? function (e) {
            const n = window.atob(e),
              t = n.length,
              a = new Uint8Array(t)
            for (let e = 0; e < t; e++) a[e] = n.charCodeAt(e)
            return a.buffer
          }
        : function (e) {
            return (function (e) {
              const n = new ArrayBuffer(e.length),
                t = new Uint8Array(n)
              for (let n = 0; n < e.length; ++n) t[n] = e[n]
              return n
            })(Buffer.from(e, "base64"))
          }
    )(
      "AGFzbQEAAAABBgFgAX8BfAMDAgAABQMBAAAHHwMGbWVtb3J5AgAHc3F1YXJlcwAACHNxdWFyZXM0AAEKjgECPwECfiAArULHuuXf9tjQm2p+IgEgASABfnxCIIoiAiACfiABQse65d/22NCbanx8QiCKIgIgAn4gAXxCIIi6C0wBAn4gAK1Cx7rl3/bY0JtqfiIBQse65d/22NCbanwiAiABIAIgASABIAF+fEIgiiIBIAF+fEIgiiIBIAF+fEIgiiIBIAF+fEIgiLoL"
    ),
    w = new WebAssembly.Module(y),
    T = new WebAssembly.Instance(w),
    b = T.exports.squares,
    z = T.exports.squares4
  var P = x.x
  const R = new URLSearchParams(window.location.search)
  function S() {
    return R.get("fxchain") || "ETHEREUM"
  }
  function _() {
    return R.getAll("fxwalletsowner") || []
  }
  const V = "tezos" == S().toLowerCase() ? 1 : 0
  let C = []
  for (let e = 1; e < 256; e++) C.push(e + 1)
  let I = {},
    E = {}
  1 != o().noshuffle &&
    (function (e) {
      let n,
        t = e.length
      for (; t > 0; )
        (n = Math.floor(F(t) * t)), t--, ([e[t], e[n]] = [e[n], e[t]])
    })(C),
    C.unshift(1),
    C.forEach((e, n) => {
      ;(I[(n += 1)] = e), (E[e] = n)
    })
  let D = new (class extends Number {
    actual() {
      return $fx.iteration
    }
    resolved() {
      return 0 == V ? this.actual() : E[this.actual()]
    }
    pair() {
      return (0 == V ? I : E)[this.actual()]
    }
    getPairs() {
      return I
    }
  })()
  function F(e) {
    return P(e) / 4294967296
  }
  class M {
    #e
    #n
    #t = 0
    constructor(e, n = !1) {
      ;(this.#n = e),
        (this.#e = n),
        n && -1 == e && (this.#n = Math.floor(1e4 * Math.random())),
        n && console.log("random seed: ", this.#n)
    }
    random_dec() {
      let e = F(this.#n + this.#t)
      return this.#t++, e
    }
    random_num(e, n) {
      return e + (n - e) * this.random_dec()
    }
    random_int(e, n) {
      return Math.floor(this.random_num(e, n + 1))
    }
    random_bool(e) {
      return this.random_dec() < e
    }
    random_choice(e) {
      return e[this.random_int(0, e.length - 1)]
    }
    random_shuffle(e) {
      let n,
        t = e.length
      for (; t > 0; )
        (n = Math.floor(this.random_dec() * t)),
          t--,
          ([e[t], e[n]] = [e[n], e[t]])
      return e
    }
  }
  let L = new M(1024 * (D.resolved() + 1) + 7)
  const A = 197384,
    H = 16777215,
    $ = 15723490,
    O = 14736598,
    B = 9144968,
    W = 3552822,
    k = 1907996,
    N = 1052689,
    U = 937983,
    q = 71679,
    X = 2707,
    G = 201894,
    j = 15039511,
    Y = 14325564,
    K = 12743201,
    J = 16711686,
    Q = 9043972,
    Z = 7340294,
    ee = 16725065,
    ne = 11144468,
    te = 1039424,
    ae = 218915,
    oe = 757052,
    re = 155936
  let ie,
    se,
    le = [
      [
        [A, O, W],
        [O, W, A],
      ],
      [
        [N, $, W],
        [$, W, B],
      ],
      [
        [A, H, W],
        [W, H, A],
      ],
      [
        [B, $, 65793],
        [$, B, k],
      ],
      [
        [W, $, 65793],
        [$, W, k],
      ],
      [[A, te, ae]],
      [
        [A, te, W],
        [$, te, k],
      ],
      [
        [k, te, H],
        [H, te, k],
      ],
      [[N, ae, B]],
      [[A, J, Z]],
      [
        [A, J, W],
        [$, J, k],
      ],
      [
        [k, J, H],
        [$, J, W],
      ],
      [[N, Z, B]],
      [
        [A, U, q],
        [U, X, A],
      ],
      [
        [A, U, W],
        [$, q, k],
      ],
      [
        [k, U, H],
        [$, U, W],
      ],
      [
        [U, H, A],
        [H, U, A],
      ],
      [
        [U, X, $],
        [$, q, U],
      ],
      [[N, q, B]],
      [
        [N, Y, K],
        [H, Y, j],
      ],
      [
        [A, W, K],
        [O, k, j],
      ],
      [
        [k, j, H],
        [$, j, W],
      ],
      [[N, ee, ne]],
      [
        [N, ee, W],
        [ee, A, W],
      ],
      [
        [A, W, ne],
        [B, k, ee],
      ],
      [[$, G, G]],
      [[$, U, G]],
      [[$, G, B]],
      [[$, U, k]],
      [[$, re, re]],
      [[$, oe, re]],
      [[$, oe, k]],
      [[$, re, B]],
      [[$, Q, Q]],
      [[$, J, Q]],
      [[$, Q, B]],
      [[$, j, j]],
      [[$, j, B]],
      [[$, G, J]],
      [[$, U, Q]],
      [[$, Q, re]],
      [[$, Q, j]],
      [[$, ee, ne]],
      [[A, te, J]],
      [[A, U, Z]],
      [[A, X, J]],
      [[A, ee, U]],
      [
        [A, U, Z],
        [U, A, Z],
      ],
      [[A, ee, U]],
      [[N, Q, U]],
      [[N, ee, U]],
      [[N, ee, J]],
      [[N, U, K]],
      [[$, re, re]],
    ]
  !(function (e = 256) {
    let n = [],
      t = []
    for (let e = 0; e < le.length; e++) {
      let a = le[e]
      a.length > 1
        ? (n.push([a[0]]), n.push([a[1]]), n.push(a), t.push(e, e, e))
        : (n.push(a), t.push(e))
    }
    let a = [...n],
      o = [...t]
    if (n.length < e) {
      let r = 0,
        i = 1
      for (let s = n.length; s < e; s++) {
        let e = n[r]
        if ((i + 1) % 2 == 0)
          if (1 == e.length) {
            let n = e[0]
            e = [[n[0], n[2], n[1]]]
          } else 2 == e.length && (e = [e[1], e[0]])
        a.push(e), o.push(t[r]), r == n.length - 1 ? ((r = 0), i++) : r++
      }
    }
    let r = new M(1),
      i = []
    for (let n = 0; n < e; n++) i.push(n)
    i.splice(0, 1), (i = r.random_shuffle(i)), i.splice(0, 0, 0)
    let s = [],
      l = []
    for (let e = 0; e < i.length; e++) {
      let n = i[e]
      s.push(a[n]), l.push(o[n])
    }
    ;(se = s), (ie = l)
  })()
  let ce = L
  function ue() {
    let e = {}
    return (
      (e.outerLayerProb = ce.random_num(0.05, 0.3)),
      (e.outerOffset = ce.random_num(0.3, 0.5)),
      (e.outerNoiseOffset = ce.random_num(0.2, 1 - e.outerOffset)),
      (e.outerNoiseScale = ce.random_num(0.2, 1)),
      (e.pm = (function () {
        let e = {}
        switch (
          ((e.type = ce.random_choice([0, 1, 1])),
          (e.sin = 0),
          (e.speed = 1),
          (e.noiseScale = 0.1),
          (e.nIndexMultiplier1 = 1e-7),
          (e.nIndexMultiplier2 = 0.001),
          (e.nRevolutions1 = 4),
          (e.nRevolutions2 = 8),
          (e.curlSize0 = 0.5),
          (e.curlSize1 = 1),
          (e.curlStrength0 = 1),
          (e.curlStrength1 = 1),
          (e.blur = 0),
          (e.blurRatio = 0.5),
          e.type)
        ) {
          case 0: {
            e.sin = 0
            let n = ce.random_num(0, 1)
            ;(e.speed = a(n, 0, 1, 1, 7)),
              (e.noiseScale = 0.1),
              (e.nIndexMultiplier1 = 1e-7),
              (e.nIndexMultiplier2 = a(n, 0, 1, 38e-5, 0.0015)),
              (e.nRevolutions1 = 4),
              (e.nRevolutions2 = ce.random_int(6, 8)),
              (e.curlSize0 = 0.16),
              (e.curlStrength0 = 1.47),
              (e.curlSize1 = ce.random_num(0.3, 0.5)),
              (e.curlStrength1 = 1.47),
              (e.blur = ce.random_bool(0.5) ? ce.random_num(0, 0.23) : 0),
              (e.blurRatio = 0.15),
              ce.random_bool(0.5) &&
                ((e.curlStrength1 *= 1.5),
                e.speed < 3 && (e.speed *= 2),
                (e.nRevolutions2 /= 2))
            break
          }
          case 1: {
            e.sin = 1
            let n = ce.random_num(0, 1)
            ;(e.speed = a(n, 0, 1, 1, 1.5)),
              (e.noiseScale = 0.1),
              (e.nIndexMultiplier1 = 1e-7),
              (e.nIndexMultiplier2 = a(n, 0, 1, 38e-5, 0.0015)),
              (e.nRevolutions1 = 4),
              (e.nRevolutions2 = ce.random_int(3, 5)),
              (e.curlSize0 = 0.16),
              (e.curlStrength0 = 1.47),
              (e.curlSize1 = ce.random_num(1, 1.5)),
              (e.curlStrength1 = 0.6),
              (e.blur = ce.random_bool(0.5) ? ce.random_num(0, 0.23) : 0),
              (e.blurRatio = 0.15)
            break
          }
        }
        return e
      })()),
      (e.contourVisibility = ce.random_choice([0.01, 0.01, 0.1, 0.1, 0.1])),
      (e.contourRadius = 1 - 0.05 * ce.random_int(0, 2)),
      e
    )
  }
  let me = {}
  ;(me.schemeIndex = (function (e) {
    return (e = fe(e)), ie[e]
  })(D.resolved())),
    (me.schemes = pe(D.resolved())),
    (me.schemeInverted = me.schemes[0][0] != me.schemes[1][0]),
    (me.motionType0 = ce.random_choice([1, 2, 2, 2, 2, 1, 0, 0, 0])),
    (me.motionType1 = ce.random_choice([1, 2, 2, 2, 2, 1, 0, 0, 0])),
    (me.invertMotiontype = ce.random_bool(0.2)),
    (me.connectionTwists = ce.random_choice([0, 6, 0, 8, 0, 10])),
    (me.spheres = [ue(), ue()]),
    (me.babyTwinScale = ce.random_num(0.1, 0.7)),
    (me.babyTwinType = ce.random_choice([0, 1, 2, 0, 0, 2, 0, 1, 0, 3, 0])),
    (me.rd = (function () {
      let e = {}
      switch (
        ((e.type = ce.random_choice([0, 1, 1, 3, 2, 2, 2])),
        (e.scale = ce.random_int(1, 10)),
        (e.mapHalfSphere = ce.random_bool(0.5)),
        (e.mapRepeat = ce.random_bool(0.5)),
        (e.startFormationDrawCenter = ce.random_bool(0.5)),
        (e.feedRate = 0.029),
        (e.killRate = 0.05876),
        e.mapHalfSphere || (e.mapRepeat = !0),
        e.type)
      ) {
        case 0:
          ;(e.mapHalfSphere = ce.random_bool(0.9)),
            (e.mapRepeat = !0),
            (e.progressionRat = 0),
            (e.startFormationNum = ce.random_int(3, 10)),
            (e.startFormationRad = ce.random_num(0.2, 0.4)),
            (e.startCircleRad = ce.random_num(0.1, 0.1)),
            (e.bumpMapSize = 0)
          break
        case 1:
          ;(e.progressionRat = 0.2),
            (e.scale = ce.random_num(1, 2)),
            (e.mapHalfSphere = ce.random_bool(0.9)),
            (e.mapRepeat = !0),
            (e.startFormationNum = ce.random_int(3, 10)),
            (e.startFormationRad = ce.random_num(0.3, 0.5)),
            (e.startCircleRad = ce.random_num(0.1, 0.1))
          break
        case 2:
          ;(e.mapHalfSphere = ce.random_bool(0.7)),
            (e.mapRepeat = ce.random_bool(0.5)),
            (e.progressionRat = ce.random_num(0.05, 0.1)),
            (e.startFormationNum = ce.random_int(3, 10)),
            (e.startFormationRad = ce.random_num(0.1, 0.5)),
            (e.startCircleRad = ce.random_num(0.05, 0.1))
          break
        case 3:
          ;(e.mapHalfSphere = ce.random_bool(0.7)),
            e.mapHalfSphere && (e.mapRepeat = ce.random_bool(0.8)),
            (e.progressionRat = ce.random_num(0.2, 0.4)),
            (e.startFormationNum = ce.random_int(1, 20)),
            (e.startFormationRad = ce.random_num(0.2, 0.5)),
            (e.startCircleRad = ce.random_num(0.1, 0.1))
      }
      return (
        e.type >= 2 &&
          ce.random_bool(0.4) &&
          ((e.type = 4),
          (e.biasX = ce.random_num(0.005, 0.1)),
          (e.biasY = ce.random_num(0.005, 0.1)),
          (e.mapRepeat = !0),
          ce.random_bool(0.5) && (e.biasX *= -1),
          ce.random_bool(0.5) && (e.biasY *= -1)),
        e
      )
    })()),
    (me.deformNoiseScale = ce.random_num(0.4, 0.6)),
    (me.deformCoreStrength = me.deformMainStrength = 0)
  let de = 0.5
  if (
    (1 == me.motionType0 && (de -= 0.1),
    1 == me.motionType1 && (de -= 0.1),
    ce.random_bool(de))
  ) {
    let e = ce.random_num(0.6, 1)
    ;(me.deformCoreStrength = ce.random_int(0, 1) * e),
      (me.deformMainStrength = ce.random_int(0, 1) * e)
  }
  function fe(e) {
    return e - 1
  }
  function pe(e) {
    e = fe(e)
    let n = se[e],
      t = []
    return t.push(n[0]), n.length > 1 ? t.push(n[1]) : t.push(n[0]), t
  }
  function ve(e) {
    let n = se,
      t = D.getPairs(),
      a = {}
    for (let o = 0; o < n.length; o++) {
      let r = n[o]
      r = 2 == r.length ? r[e] : r[0]
      let i = "0x" + r[e + 1].toString(16).padStart(6, "0"),
        s = o + 1
      1 == e && (s = t[s]), (a[s] = i)
    }
    return a
  }
  ;(me.rotationSpeedY = ce.random_num(0.25, 0.3)),
    (me.rotationSpeedZ = ce.random_num(0, 0.5 * me.rotationSpeedY)),
    (me.rotateCoreZ = !1),
    (me.flipRotation = ce.random_bool(0.6)),
    (me.rotationSpeedDiagram = ce.random_num(0.05, 0.15)),
    ce.random_bool(0.5) && (me.rotationSpeedDiagram *= -1),
    ce.random_bool(0.5) && (me.rotationSpeedZ = 0),
    (me.mainType = 0),
    ce.random_bool(0.03) &&
      ((me.mainType = 1),
      (me.rotationSpeedZ = ce.random_num(0, 0.5 * me.rotationSpeedY)),
      (me.deformMainStrength = 0)),
    (me.bumpMapSize = ce.random_num(0.5, 1)),
    0 == me.rd.type && (me.bumpMapSize = 0),
    2 == me.motionType0 && 2 == me.motionType1 && (me.rotateCoreZ = !0),
    0 == me.motionType0 && (me.spheres[0].contourVisibility = 0.1),
    0 == me.motionType1 && (me.spheres[1].contourVisibility = 0.1)
  let ge = me
  class he {
    #a = {}
    #o = {}
    constructor(e) {
      Object.keys(e).forEach(n => {
        this.addParameter(n, e[n].type, e[n].value, e[n].metaData)
      })
    }
    addParameter(e, n, t, a) {
      ;(this.#a[e] = { type: n, metaData: a }), (this.#o[e] = t)
    }
    injectUniforms(e) {
      Object.keys(this.#a).forEach(n => {
        e[n] = { value: this.#o[n] }
      })
    }
    getUniformsString() {
      let e = ""
      return (
        Object.keys(this.#a).forEach(n => {
          e += "uniform " + this.#a[n].type + " " + n + ";\n"
        }),
        e
      )
    }
    getValues() {
      return this.#o
    }
    setValue(e, n) {
      this.#o[e] = n
    }
    getParam(e) {
      return this.#a[e]
    }
    getParams() {
      return this.#a
    }
  }
  let xe = "vec2 uvScale = vec2(2.0, 1.0);",
    ye = "vec2 clampVal = vec2(0.0, 1.0);"
  ge.rd.mapHalfSphere && (xe = "vec2 uvScale = vec2(1.0, 1.0);"),
    ge.rd.mapRepeat && (ye = "vec2 clampVal = vec2(-1.0, 1.0);")
  let we = `\nvec2 uvFromPolar (vec3 p)\n{\n${xe}\n${ye}\nvec3 p2 = cartesianToPolar(p);\nvec3 p3 = polarToCartesian(p2);\nreturn vec2(clamp(p3.y / (PI * uvScale.x), clampVal.x, clampVal.y), (p3.z - PI*.5) / (PI * uvScale.y));\n}\n`,
    Te = ge.spheres[0].pm,
    be = new he({
      extraSin: {
        type: "int",
        value: Te.sin,
        metaData: { min: 0, max: 1, step: 1 },
      },
      speed: {
        type: "float",
        value: Te.speed,
        metaData: { min: 0, max: 10, step: 0.1 },
      },
      noiseScale: {
        type: "float",
        value: Te.noiseScale,
        metaData: { min: 0, max: 5, step: 0.01 },
      },
      nIndexMultiplier1: {
        type: "float",
        value: Te.nIndexMultiplier1,
        metaData: { min: 0, max: 1e-7, step: 1e-8 },
      },
      nIndexMultiplier2: {
        type: "float",
        value: Te.nIndexMultiplier2,
        metaData: { min: 0, max: 0.005, step: 1e-5 },
      },
      nRevolutions1: {
        type: "float",
        value: Te.nRevolutions1,
        metaData: { min: 1, max: 16, step: 1 },
      },
      nRevolutions2: {
        type: "float",
        value: Te.nRevolutions2,
        metaData: { min: 1, max: 16, step: 1 },
      },
      curlSize0: {
        type: "float",
        value: Te.curlSize0,
        metaData: { min: 0, max: 5, step: 0.01 },
      },
      curlStrength0: {
        type: "float",
        value: Te.curlStrength0,
        metaData: { min: 0, max: 5, step: 0.01 },
      },
      curlSize1: {
        type: "float",
        value: Te.curlSize1,
        metaData: { min: 0, max: 5, step: 0.01 },
      },
      curlStrength1: {
        type: "float",
        value: Te.curlStrength1,
        metaData: { min: 0, max: 5, step: 0.01 },
      },
      blur: {
        type: "float",
        value: Te.blur,
        metaData: { min: 0, max: 1, step: 0.001 },
      },
      blurRatio: {
        type: "float",
        value: Te.blurRatio,
        metaData: { min: 0, max: 1, step: 0.001 },
      },
      connectionTwists: {
        type: "float",
        value: ge.connectionTwists,
        metaData: { min: 0, max: 16, step: 2 },
      },
    })
  let ze = THREE,
    Pe = new ze.Texture()
  1 == ge.gradientType || ge.gradientType
  class Re {
    #r
    #t
    #i
    #s
    #l
    #c
    constructor() {
      let e = this
      addEventListener("storage", n => {
        if ("windows" == n.key) {
          let t = JSON.parse(n.newValue),
            a = e.#u(e.#r, t),
            o = e.#m(e.#r, t)
          e.#r = t
          for (let n = 0; n < o.length; n++) e.#c && e.#c(o[n])
          a && e.#l && e.#l()
        }
      }),
        window.addEventListener("beforeunload", function (n) {
          let t = e.getWindowIndexFromId(e.#i)
          e.#r.splice(t, 1), e.updateWindowsLocalStorage()
        })
    }
    #u(e, n) {
      if (e.length != n.length) return !0
      {
        let t = !1
        for (let a = 0; a < e.length; a++) e[a].id != n[a].id && (t = !0)
        return t
      }
    }
    #m(e, n) {
      let t = []
      for (let a = 0; a < n.length; a++) {
        let o = n[a]
        for (let n = 0; n < e.length; n++) {
          let a = e[n]
          if (o.id == a.id)
            for (const [e, n] of Object.entries(o.metaData)) {
              let r = a.metaData[e]
              null == r &&
                t.push({ id: o.id, key: e, value: n, newlyAdded: !0 }),
                JSON.stringify(r) !== JSON.stringify(n) &&
                  t.push({ id: o.id, key: e, value: n, newlyAdded: !1 })
            }
        }
      }
      return t
    }
    init(e) {
      ;(this.#r = JSON.parse(localStorage.getItem("windows")) || []),
        (this.#t = localStorage.getItem("count") || 0),
        this.#t++,
        (this.#i = this.#t)
      let n = this.getWinShape(),
        t = { id: this.#i, shape: n, metaData: e }
      this.#r.push(t),
        localStorage.setItem("count", this.#t),
        this.updateWindowsLocalStorage()
    }
    setMetaData(e, n) {
      let t = this.getThisWindowData()
      if (t.metaData[e] != n) {
        ;(t.metaData[e] = n), console.log("set metaData '" + e + "'' to " + n)
        let a = this.getWindowIndexFromId(this.#i)
        return (
          (this.#r[a].metaData = t.metaData),
          this.updateWindowsLocalStorage(),
          !0
        )
      }
      return !1
    }
    getWinShape() {
      return {
        x: window.screenLeft,
        y: window.screenTop,
        w: window.innerWidth,
        h: window.innerHeight,
      }
    }
    getWindowIndexFromId(e) {
      let n = -1
      for (let t = 0; t < this.#r.length; t++) this.#r[t].id == e && (n = t)
      return n
    }
    updateWindowsLocalStorage() {
      localStorage.setItem("windows", JSON.stringify(this.#r))
    }
    update() {
      let e = this.getWinShape(),
        n = this.getThisWindowData()
      if (
        e.x != n.shape.x ||
        e.y != n.shape.y ||
        e.w != n.shape.w ||
        e.h != n.shape.h
      ) {
        let n = this.getWindowIndexFromId(this.#i)
        ;(this.#r[n].shape = e),
          this.#s && this.#s(),
          this.updateWindowsLocalStorage()
      }
    }
    setWinShapeChangeCallback(e) {
      this.#s = e
    }
    setWinChangeCallback(e) {
      this.#l = e
    }
    setMetaDataChangeCallback(e) {
      this.#c = e
    }
    getWindows() {
      return this.#r
    }
    numWindows() {
      return this.#r.length
    }
    getThisWindowData() {
      let e = this.getWindowIndexFromId(this.#i)
      return this.#r[e]
    }
    getThisWindowID() {
      return this.#i
    }
  }
  class Se extends class {
    #d
    #f
    #p
    #v
    #g
    #h
    #x
    #y = []
    #w = 1
    #T = 0
    #b = 0
    #z
    constructor(e, n, t, a, o, r = {}) {
      ;(n = this.#P(n)),
        (this.#d = {
          type: THREE.FloatType,
          format: THREE.RGBAFormat,
          wrapS: r.wrapS || THREE.ClampToEdgeWrapping,
          wrapT: r.wrapT || THREE.ClampToEdgeWrapping,
          minFilter: THREE.LinearFilter,
          magFilter: THREE.LinearFilter,
          depthBuffer: !1,
        }),
        (this.#p = e),
        (this.#f = new THREE.Scene()),
        (this.#v = new THREE.Camera()),
        (this.#v.position.z = 1),
        (this.#h = new THREE.Vector2(a, o)),
        this.#y.push(this.#R(a, o)),
        this.#y.push(this.#R(a, o)),
        ((t = t || {}).iteration = { value: 0 }),
        (t.prevTex = { value: this.#y[0].texture }),
        (this.uniforms = t),
        (this.#x = this.#S(n, t)),
        (this.#g = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), this.#x)),
        this.#f.add(this.#g),
        this.#_()
    }
    #_() {
      let e =
        "\nuniform vec2 screenSize;\nvoid main ()\n{\nvec2 uv = gl_FragCoord.xy / resolution;\ngl_FragColor = vec4(texture2D(prevTex, uv).xyz, 1.0);\n}\n"
      e = this.#P(e)
      let n = new THREE.Vector2()
      this.#p.getSize(n)
      let t = {
        prevTex: { value: this.#y[0].texture },
        screenSize: { value: n },
      }
      this.#z = this.#S(e, t)
    }
    #P(e) {
      return (e =
        "\nuniform int iteration;\nuniform sampler2D prevTex;\n\n" + e)
    }
    #S(e, n) {
      n = n || {}
      const t = new THREE.ShaderMaterial({
        uniforms: n,
        vertexShader: this.#V(),
        fragmentShader: e,
      })
      return (
        (t.defines.resolution =
          "vec2( " + this.#h.x.toFixed(1) + ", " + this.#h.x.toFixed(1) + " )"),
        t
      )
    }
    #R = function (e, n, t, a, o, r) {
      ;(e = e || sizeX),
        (n = n || sizeY),
        (t = t || THREE.RepeatWrapping),
        (a = a || THREE.RepeatWrapping),
        (o = o || THREE.NearestFilter),
        (r = r || THREE.NearestFilter)
      return new THREE.WebGLRenderTarget(e, n, this.#d)
    }
    #V() {
      return "void main() {\n\n gl_Position = vec4( position, 1.0 );\n\n}\n"
    }
    #C() {
      ;(this.#w = this.#T), (this.#T = 0 == this.#T ? 1 : 0)
    }
    render() {
      const e = this.#p.getRenderTarget(),
        n = this.getCurrentTarget()
      ;(this.#g.material = this.#x),
        this.updateUniforms(),
        this.#p.setRenderTarget(n),
        this.#p.render(this.#f, this.#v),
        this.#p.setRenderTarget(e),
        this.#C(),
        this.#b++
    }
    getCurrentTarget() {
      return this.#y[this.#T]
    }
    getPrevTarget() {
      return this.#y[this.#w]
    }
    updateUniforms() {
      const e = this.getPrevTarget()
      let n = this.#x.uniforms
      return (n.iteration.value = this.#b), (n.prevTex.value = e.texture), n
    }
    renderToScreen() {
      let e = new THREE.Vector2()
      this.#p.getSize(e),
        (this.#z.uniforms.screenSize.value = e),
        (this.#g.material = this.#z),
        this.#p.render(this.#f, this.#v)
    }
    getTexture() {
      return this.#y[this.#T].texture
    }
    getSize() {
      return this.#h
    }
    restart() {
      this.#b = 0
    }
  } {
    parameters
    constructor(e, n, t, a, o = {}) {
      a =
        a ||
        "\nvoid main ()\n{\nvec4 c;\nif (iteration == 0)\n{\nvec2 coord = gl_FragCoord.xy;\nfloat circ = 1.0 - round(length(coord - resolution * .5) / (resolution.x * .5));\nif (circ > 0.0) c = vec4(0.0, 1.0, 0.0, 1.0);\nelse c = vec4(1.0, 0.0, 0.0, 1.0);\n}\nelse\n{\nvec2 uv = gl_FragCoord.xy / resolution;\nfloat s = scale;\nvec2 b = vec2(biasX, biasY);\nc = reactionDiffusion(prevTex, gl_FragCoord.xy, resolution, Da * s, Db * s, f, k, t / s, b);\n}\ngl_FragColor = c;\n}\n"
      let r = new he({
          Da: { type: "float", value: 1, metaData: { min: 0, max: 1 } },
          Db: { type: "float", value: 0.5, metaData: { min: 0, max: 1 } },
          f: {
            type: "float",
            value: 0.029,
            metaData: { min: 0, max: 0.1, step: 0.001 },
          },
          k: {
            type: "float",
            value: 0.05876,
            metaData: { min: 0, max: 0.1 },
            step: 0.001,
          },
          t: { type: "float", value: 1, metaData: { min: 0, max: 1 } },
          scale: { type: "float", value: 1, metaData: { min: 1, max: 100 } },
          biasX: {
            type: "float",
            value: 0,
            metaData: { min: -0.1, max: 0.1, step: 0.001 },
          },
          biasY: {
            type: "float",
            value: 0,
            metaData: { min: -0.1, max: 0.1, step: 0.001 },
          },
        }),
        i = {}
      r.injectUniforms(i),
        super(
          e,
          `\n${r.getUniformsString()}\n\nvec4 reactionDiffusion (sampler2D tex, vec2 fragCoord, vec2 res, float Da, float Db, float f, float k, float t, vec2 bias)\n{\nvec2 uv = fragCoord/res.xy;\nvec2 r = 1.0/res.xy;\nvec2 laplacian = -texture2D(tex,uv).xy\n+(0.2+bias.x)*texture2D(tex,uv + vec2(1.0,0.0)*r).xy\n+(0.2-bias.x)*texture2D(tex,uv + vec2(-1.0,0.0)*r).xy\n+(0.2+bias.y)*texture2D(tex,uv + vec2(0.0,1.0)*r).xy\n+(0.2-bias.y)*texture2D(tex,uv + vec2(0.0,-1.0)*r).xy\n+(0.05)*texture2D(tex,uv + vec2(1.0,1.0)*r).xy\n+(0.05)*texture2D(tex,uv + vec2(1.0,-1.0)*r).xy\n+(0.05)*texture2D(tex,uv + vec2(-1.0,1.0)*r).xy\n+(0.05)*texture2D(tex,uv + vec2(-1.0,-1.0)*r).xy;\nvec2 last = texture(tex,uv).xy;\nfloat A = last.x;\nfloat B = last.y;\nA = A + (Da*laplacian.x - A*B*B + f*(1.0 - A))*t;\nB = B + (Db*laplacian.y + A*B*B - (k + f)*B)*t;\nreturn vec4(A, B, 0.0, 1.);\n}\n\n${f}\n${a}\n`,
          i,
          n,
          t,
          o
        ),
        (this.parameters = r)
    }
    updateUniforms() {
      let e = super.updateUniforms()
      this.parameters.injectUniforms(e)
    }
    render() {
      super.render()
    }
  }
  let _e =
      "\nvec3 cartesianToPolar (vec3 p)\n{\nvec3 p2;\np2.x = cos(p.z);\np2.y = sin(p.z);\np2.z = sin(p.y) * p2.x;\np2.x = cos(p.y) * p2.x;\nreturn p2;\n}",
    Ve =
      "\nvec3 polarToCartesian (vec3 p)\n{\nfloat y = atan(p.z, p.x);\nfloat z = atan(p.y, sqrt(pow(p.x, 2.0) + pow(p.z, 2.0)));\nreturn vec3(0.0, y, z);\n}",
    Ce = "vec2 uvScale = vec2(2.0, 1.0);",
    Ie = "vec2 clampVal = vec2(0.0, 1.0);"
  ge.rd.mapHalfSphere && (Ce = "vec2 uvScale = vec2(1.0, 1.0);"),
    ge.rd.mapRepeat && (Ie = "vec2 clampVal = vec2(-1.0, 1.0);")
  let Ee = `\nvec2 uvFromPolar (vec3 p)\n{\n${Ce}\n${Ie}\nvec3 p2 = cartesianToPolar(p);\nvec3 p3 = polarToCartesian(p2);\nreturn vec2(clamp(p3.y / (PI * uvScale.x), clampVal.x, clampVal.y), (p3.z - PI*.5) / (PI * uvScale.y));\n}\n`
  let De = THREE,
    Fe = new De.Texture(),
    Me = 100,
    Le = 100
  let Ae = `\nfloat circle (vec2 uv, vec2 center, float rad)\n{\nreturn 1.0 - clamp(round(length(uv - center) / rad), 0.0, 1.0);\n}\nfloat strokedCircle (vec2 uv, vec2 center, float rad, float thickness)\n{\nfloat d = length(uv - center);\nd = abs(d - rad);\nd = clamp(round(d / thickness), 0.0, 1.0);\nreturn 1.0 - d;\n}\nfloat circFormation (vec2 uv, int n, float fRad, float cRad, bool center)\n{\nfloat b = 0.0;\nfloat aStep = (PI * 2.0) / float(n);\nfor (int i = 0; i < n; i++)\n{\nfloat a = aStep * float(i) + PI * 1.5;\nvec2 p;\np.x = .5 + cos(a) * fRad;\np.y = .5 + sin(a) * fRad;\nb += circle(uv, p, cRad);\n}\nif (center) b += circle(uv, vec2(.5, .5), cRad);\nreturn b;\n}\nvoid main ()\n{\nvec4 c;\nvec2 uv = gl_FragCoord.xy / resolution;\nfloat b = circFormation(uv, ${ge.rd.startFormationNum}, ${ge.rd.startFormationRad.toPrecision(5)}, ${ge.rd.startCircleRad.toPrecision(5)}, ${ge.rd.startFormationDrawCenter});\nif (iteration == 0)\n{\nif (b > 0.5) c = vec4(0.0, 1.0, 0.0, 1.0);\nelse c = vec4(1.0, 0.0, 0.0, 1.0);\n}\nelse\n{\nvec2 uv = gl_FragCoord.xy / resolution;\nfloat s = scale;\nvec2 b = vec2(biasX, biasY);\nc = reactionDiffusion(prevTex, gl_FragCoord.xy, resolution, Da * s, Db * s, f, k, t / s, b);\n}\ngl_FragColor = c;\n}\n`
  class He {
    #I = !1
    #E
    #D
    #F
    #M
    #L
    #A
    #p
    #H
    #$
    #O
    #B
    #W
    #k
    #N
    #U
    #q
    #X
    #G
    #j
    #Y
    #K
    #J
    #Q
    #Z
    #ee
    #ne
    #i
    #te
    #ae
    constructor(e, n, t, a, o, r = !1, i = !1) {
      ;(this.#te = a),
        (this.#H = n),
        (this.#D = 0),
        (this.#F = 0),
        (this.#A = 0),
        (this.#p = e),
        (this.#E = -1),
        (this.#ne = i),
        (this.#i = t),
        (this.#ae = r),
        (this.#ee = o),
        r && (this.#Q = this.#oe()),
        this.#Q || (this.#re(), this.#ie(), this.#se())
    }
    #re() {
      let e = { wrapS: THREE.RepeatWrapping, wrapT: THREE.RepeatWrapping }
      this.#$ = new Se(this.#p, 400, 400, Ae, e)
      let n = new THREE.MeshBasicMaterial({
          color: 16777215,
          side: THREE.DoubleSide,
          map: this.#$.getTexture(),
        }),
        t = 200,
        a = new THREE.Mesh(new THREE.PlaneGeometry(t, t), n)
      ;(a.position.x = 100),
        (a.position.y = 100),
        this.#ne && this.#H.add(a),
        (this.#M = this.#te.scale),
        (this.#L = this.#te.progressionRat),
        this.#$.parameters.setValue("scale", this.#M),
        this.#$.parameters.setValue("f", ge.rd.feedRate),
        this.#$.parameters.setValue("k", ge.rd.killRate),
        this.#$.parameters.setValue("biasX", ge.rd.biasX),
        this.#$.parameters.setValue("biasY", ge.rd.biasY)
    }
    #ie() {
      ;(this.#O = new l(Me, Le, this.#p)),
        (this.#B = this.#O.createTexture()),
        (this.#W = this.#O.addVariable(
          "texturePolarAcc",
          `\nuniform int frame;\nuniform float time;\nuniform sampler2D rdTex;\n${f}\n${d}\n${Ve}\n${_e}\n${Ee}\nfloat raVal (vec2 uv)\n{\nreturn 1.0 - pow(1.0 - clamp(texture2D(rdTex, uv).g + .3, 0.0, 1.0), 1.0);\n}\nvoid main () \n{\nfloat nPoints = resolution.x * resolution.y;\nfloat i = (gl_FragCoord.y * resolution.x) + gl_FragCoord.x;\nvec2 uv = gl_FragCoord.xy / resolution.xy;\nvec4 pPos = texture2D(texturePolarPos, uv);\nvec3 acc;\nvec2 uv2 = uvFromPolar(pPos.xyz);\nfloat rdTexSize = 400.0;\nfloat o = 1.0/rdTexSize;\nfloat t0 = raVal(uv2 + vec2(-1., -1.) * o);\nfloat t1 = raVal(uv2 + vec2( 0., -1.) * o);\nfloat t2 = raVal(uv2 + vec2( 1., -1.) * o);\nfloat m0 = raVal(uv2 + vec2(-1., 0.) * o);\nfloat m1 = raVal(uv2 + vec2( 0., 0.) * o);\nfloat m2 = raVal(uv2 + vec2( 1., 0.) * o);\nfloat b0 = raVal(uv2 + vec2(-1., 1.) * o);\nfloat b1 = raVal(uv2 + vec2( 0., 1.) * o);\nfloat b2 = raVal(vec2( 1., 1.) * o);\nvec2 dir = vec2(0.0);\ndir += clamp(t0 - m1, 0., 1.) * vec2(-1., -1.);\ndir += clamp(t1 - m1, 0., 1.) * vec2( 0., -1.);\ndir += clamp(t2 - m1, 0., 1.) * vec2( 1., -1.);\ndir += clamp(m0 - m1, 0., 1.) * vec2(-1., 0.);\ndir += clamp(m2 - m1, 0., 1.) * vec2( 1., 0.);\ndir += clamp(b0 - m1, 0., 1.) * vec2(-1., 1.);\ndir += clamp(b1 - m1, 0., 1.) * vec2( 0., 1.);\ndir += clamp(b2 - m1, 0., 1.) * vec2( 1., 1.);\nacc.y = dir.x;\nacc.z = dir.y;\nacc *= .1;\nacc += vec3(0.0, sin(float(frame) * .001), sin(float(frame) * .002)) * 0.01 * pow(1.0 - m1, 10.0);\ngl_FragColor = vec4(acc.xyz, 1.0);\n}`,
          this.#B
        )),
        (this.#W.material.uniforms.frame = { value: 0 }),
        (this.#W.material.uniforms.rdTex = { value: this.#$.getTexture() }),
        (this.#k = this.#O.createTexture()),
        (this.#N = this.#O.addVariable(
          "texturePolarVel",
          `\nuniform int frame;\nuniform float time;\n${f}\n${d}\nvoid main () \n{\nfloat nPoints = resolution.x * resolution.y;\nfloat i = (gl_FragCoord.y * resolution.x) + gl_FragCoord.x;\nvec2 uv = gl_FragCoord.xy / resolution.xy;\nvec4 pVel = texture2D(texturePolarVel, uv);\nvec4 pAcc = texture2D(texturePolarAcc, uv);\nvec3 vel = vec3(0.0);\nif (frame > 0)\n{\nvel = pVel.xyz + pAcc.xyz; \n}\nvel *= .2;\ngl_FragColor = vec4(vel.xyz, 1.0);\n}`,
          this.#k
        )),
        (this.#N.material.uniforms.frame = { value: 0 }),
        (this.#U = this.#O.createTexture()),
        (this.#q = this.#O.addVariable(
          "texturePolarPos",
          `\nuniform int frame;\nuniform float time;\nuniform sampler2D rdTex;\n${f}\n${d}\nvoid main () \n{\nfloat nPoints = resolution.x * resolution.y;\nfloat i = (gl_FragCoord.y * resolution.x) + gl_FragCoord.x;\nvec2 uv = gl_FragCoord.xy / resolution.xy;\nvec4 pPos = texture2D(texturePolarPos, uv);\nvec4 pVel = texture2D(texturePolarVel, uv);\nvec3 pos;\nif (frame == 0)\n{\npos.y = hash12(uv * 300.0) * PI * 2.0;\npos.z = PI * .5 + hash12(uv * 400.0) * PI * 2.0;\n}\nelse\n{\npos = pPos.xyz + pVel.xyz;\n}\ngl_FragColor = vec4(pos.xyz, 1.0);\n}`,
          this.#U
        )),
        (this.#q.material.uniforms.frame = { value: 0 }),
        (this.#q.material.uniforms.rdTex = { value: this.#$.getTexture() }),
        (this.#X = this.#O.createTexture()),
        (this.#G = this.#O.addVariable(
          "texturePosition",
          `\nuniform float time;\nuniform int frame;\nuniform float scale;\nuniform sampler2D rdTex;\n${f}\n${u}\n${Ve}\n${_e}\n${Ee}\nvoid main () \n{\nvec2 uv = gl_FragCoord.xy / resolution.xy;\nvec4 polPos = texture2D(texturePolarPos, uv);\nfloat yRot = polPos.y;\nfloat zRot = polPos.z;\nvec2 uv2 = uvFromPolar(polPos.xyz);\nfloat b = texture2D(rdTex, uv2).g;\nvec4 pos;\nfloat radius = 200.0;\npos.x = cos(zRot) * radius;\npos.y = sin(zRot) * radius;\npos.z = sin(yRot) * pos.x;\npos.x = cos(yRot) * pos.x;\npos.w = b;\ngl_FragColor = pos;\n}`,
          this.#X
        )),
        (this.#G.material.uniforms.frame = { value: 0 }),
        (this.#G.material.uniforms.rdTex = { value: this.#$.getTexture() }),
        (this.#G.material.uniforms.offset = { value: new De.Vector3() }),
        (this.#G.material.uniforms.scale = { value: 1 }),
        this.#O.setVariableDependencies(this.#W, [this.#q]),
        this.#O.setVariableDependencies(this.#N, [this.#N, this.#W]),
        this.#O.setVariableDependencies(this.#q, [this.#q, this.#N]),
        this.#O.setVariableDependencies(this.#G, [this.#q])
      var e = this.#O.init()
      null !== e && console.error(e)
    }
    #se() {
      const e = new THREE.BufferGeometry()
      let n = []
      for (let e = 0; e < 1e4; e++) n.push(0, 0, 0)
      e.setAttribute(
        "position",
        new THREE.BufferAttribute(new Float32Array(n), 3)
      )
      let t = (function (e, n) {
        let t = De.UniformsUtils.merge([
            De.ShaderLib.phong.uniforms,
            { offset: new De.Vector3() },
            { diffuse: { value: new De.Color(16777215) } },
            { frame: { value: 0 } },
            { scale: { value: 1 } },
            { posTex: { type: Fe } },
            { accTex: { type: Fe } },
            { velTex: { type: Fe } },
          ]),
          a = De.ShaderLib.points.vertexShader,
          o = De.ShaderLib.points.fragmentShader
        return (
          (a = `\nuniform int frame;\nattribute int indexAttr;\nvarying float b;\nuniform sampler2D posTex;\nuniform sampler2D accTex;\nuniform sampler2D velTex;\nuniform float scale;\nuniform vec3 canvasSize;\n${p}\nvoid main() \n{\nint i = gl_VertexID;\nfloat nX = ${e.toPrecision(5)};\nfloat nY = ${n.toPrecision(5)};\nfloat n = nX * nY;\nfloat y = floor((float(i) / nX) + .0001);\nfloat x = float(i) - (y * nX);\nvec2 uv = vec2(x, y) / vec2(nX, nY);\nvec4 pos;\npos = texture2D(posTex, uv);\nb = pos.w;\npos.w = 1.0;\ngl_Position = projectionMatrix * modelViewMatrix * pos;\ngl_PointSize = 4.0;\n}`),
          (o = o.replace(
            "#include <common>",
            "\n#include <common>\nuniform float time;\nvarying vec4 color;\nvarying float b;\n"
          )),
          (o = o.replace(
            "#include <fog_fragment>",
            "\ngl_FragColor = vec4(.1, b, b, 1.0);\nfloat a = 1.0 - pow(length(gl_PointCoord - vec2(.5, .5)) / .5, 100.0);\nif (a <= 0.0) discard;\n#include <fog_fragment>\n"
          )),
          new De.ShaderMaterial({
            uniforms: t,
            vertexShader: a,
            side: De.DoubleSide,
            wireframe: !1,
            fragmentShader: o,
            lights: !0,
            fog: !0,
            name: "custom-material",
            depthWrite: !0,
            depthTest: !0,
            transparent: !0,
            blending: THREE.AdditiveBlending,
          })
        )
      })(Me, Le)
      ;(this.#j = new THREE.Points(e, t)), this.#ne && this.#H.add(this.#j)
    }
    compute(e) {
      if (this.#Q)
        (this.#K = []),
          this.#Q.poly.forEach(e => {
            this.#K.push(new THREE.Vector3(e.x, e.y, e.z))
          }),
          (this.#I = !0)
      else {
        let n = 12800 * (this.#M - 0.3 * this.#M) * this.#L
        if ((this.#L <= 0 && (n = 1), -1 == this.#E))
          i("total"), i("RD"), (this.#E = 0)
        else if (0 == this.#E) {
          let e = performance.now(),
            t = 0
          for (; this.#F < n && t < 0.8; ) {
            let a = n <= 1 ? 1 : 20
            for (let e = 0; e < a; e++) this.#$.render(), this.#F++
            let o = performance.now()
            ;(t += o - e), (e = o)
          }
          this.#F >= n && ((this.#E = 1), s("RD"), i("particle sim"))
        } else if (1 == this.#E) {
          let e = performance.now(),
            n = 0
          for (; this.#A < 250 && n < 10; ) {
            ;(this.#q.material.uniforms.frame = { value: this.#A }),
              (this.#N.material.uniforms.frame = { value: this.#A }),
              (this.#W.material.uniforms.frame = { value: this.#A }),
              (this.#G.material.uniforms.frame = { value: this.#A }),
              this.#O.compute(),
              this.#A++
            let t = performance.now()
            ;(n += t - e), (e = t)
          }
          this.#A >= 250 && (this.#E = 2)
        } else if (2 == this.#E) {
          s("particle sim"), i("copy pixels")
          const e = 4e4,
            n = new Float32Array(e),
            t = this.#O.getCurrentRenderTarget(this.#G)
          this.#p.readRenderTargetPixels(t, 0, 0, Me, Le, n), (this.#Y = [])
          for (let t = 0; t < e; t += 4)
            if (n[t + 3] > 0.1) {
              let e = new De.Vector3(n[t], n[t + 1], n[t + 2], n[t + 3])
              this.#Y.push(e)
            }
          s("copy pixels"), i("reorder"), (this.#K = []), (this.#E = 3)
        } else if (3 == this.#E) {
          let e
          0 == this.#K.length
            ? ((e = this.#Y[0]), this.#Y.splice(0, 1), this.#K.push(e))
            : (e = this.#K[this.#K.length - 1]),
            Math.ceil(a(this.#Y.length, 3e3, 0, 20, 250, !0))
          let n = Date.now(),
            t = 0
          for (; this.#Y.length > 0 && t < 10; ) {
            let a = 1e7,
              o = 0
            for (let n = 0, t = this.#Y.length; n < t; n++) {
              let t = this.#Y[n].clone().sub(e).length()
              t < a && ((a = t), (o = n))
            }
            ;(e = this.#Y[o]), this.#Y.splice(o, 1), this.#K.push(e)
            let r = Date.now()
            ;(t += r - n), (n = r)
          }
          0 == this.#Y.length && (s("reorder"), (this.#E = 4))
        } else if (4 == this.#E) {
          i("simplify")
          let e = [],
            n = this.#K[0],
            t = 5 * this.#M
          t > 50 && (t = 50)
          let a = [n]
          for (let o = 1; o < this.#K.length; o++) {
            let r = this.#K[o]
            if (r.clone().sub(n).length() < t) a.push(r.clone())
            else {
              let t = a[0]
              for (let e = 1; e < a.length; e++) t.add(a[e])
              t.divideScalar(a.length), (a = [r]), (n = r), e.push(t)
            }
          }
          s("simplify"), (this.#K = e), (this.#E = 5)
        } else if (5 == this.#E) {
          i("redivide"), this.#K.push(this.#K[0].clone().addScalar(1e-4))
          let e = this.#K[0],
            n = 0,
            t = []
          for (let a = 0; a < this.#K.length; a++) {
            ;(n += this.#K[a].clone().sub(e).length()), t.push(n)
          }
          let a = this.#K.length,
            o = this.#ee,
            r = [],
            l = n / (o - 1)
          for (let e = 0; e < o; e++) {
            let n,
              o = l * e
            for (n = 0; n < a && !(o >= t[n] && o < t[n + 1]); n++);
            n > this.#K.length - 2 && (n = n = this.#K.length - 2)
            let i = t[n],
              s = (o - i) / (t[n + 1] - i),
              c = this.#K[n],
              u = this.#K[n + 1],
              m = c.clone().lerp(u, s)
            r.push(m)
          }
          ;(this.#K = r), s("redivide"), (this.#E = 6)
        } else if (6 == this.#E) {
          const e = new THREE.BufferGeometry().setFromPoints(this.#K),
            n = new THREE.LineBasicMaterial({ color: 16777215 })
          ;(this.#J = new THREE.Line(e, n)),
            this.#ne && this.#H.add(this.#J),
            (this.#E = 7)
        } else
          7 == this.#E &&
            (this.#I || (this.#ae && this.#le(), s("total"), (this.#E = 8)),
            (this.#I = !0))
        this.#ne &&
          (this.#J &&
            ((this.#J.rotation.y = 0.5 * e),
            (this.#J.position.x = 250),
            (this.#J.position.y = 500)),
          this.#j &&
            ((this.#j.rotation.y = 0.5 * e),
            (this.#j.position.x = 250),
            (this.#j.position.y = 500))),
          (this.#j.material.uniforms.posTex = {
            value: this.#O.getCurrentRenderTarget(this.#G).texture,
          }),
          (this.#j.material.uniforms.frame = { value: this.#D })
      }
      this.#D++
    }
    #le() {
      let e = localStorage.getItem("raPolylines")
      e = e ? JSON.parse(e) : {}
      let n = { id: this.#i, poly: this.#K }
      ;(e[this.#i] = n), localStorage.setItem("raPolylines", JSON.stringify(e))
    }
    #oe() {
      let e = localStorage.getItem("raPolylines")
      if (!e) return console.log("no local version"), !1
      {
        this.#Z = JSON.parse(e)
        let n = this.#Z[this.#i]
        if ((console.log("local lines", e), n))
          return console.log("loaded local version with id: " + this.#i), n
        console.log("no local version with right id")
      }
    }
    isDone() {
      return this.#I
    }
    getPolylineVertices() {
      return this.#K
    }
    renderDebug() {
      this.#$.renderToScreen()
    }
    getPoints() {
      return this.#j
    }
    getTexture() {
      return this.#$.getTexture()
    }
  }
  const $e = THREE
  function Oe(e, n, t = 0, a = 0, o = 0) {
    return We(e, t, t + 2 * Math.PI, n, a, o)
  }
  function Be(e, n, t, a = 0, o = 0) {
    return Oe(e, n, t, a, o)
  }
  function We(e, n, t, a, o = 0, r = 0, i = !0) {
    a += 1
    const s = []
    let l = t - n
    l < 0 && (l = 2 * Math.PI + l)
    let c = l / (a - 1)
    for (let t = 0; t < a; t++) {
      let a = n + c * t
      s.push(new $e.Vector3(o + Math.cos(a) * e, r + Math.sin(a) * e, 0))
    }
    return s
  }
  function ke(e, n, t, a, o = 0, r = 0) {
    const i = []
    let s = t - n
    s < 0 && (s = 2 * Math.PI + s)
    let l = 2 * Math.PI * e * (s / (2 * Math.PI)),
      c = Math.round(l / a / 3),
      u = 20 * c,
      m = s / (u - 1)
    for (let t = 0; t < u; t++) {
      let s = n + m * t,
        l = e + Math.sin((t / (u - 1)) * Math.PI * c) * a
      i.push(new $e.Vector3(o + Math.cos(s) * l, r + Math.sin(s) * l, 0))
    }
    return i
  }
  function Ne(e, n, t, a, o = 0, r = 0) {
    let i = 0.5,
      s = t - n
    s < 0 && (s = 2 * Math.PI + s)
    let l = 2 * Math.PI * e * (s / (2 * Math.PI)),
      c = 2 * a * 2,
      u = Math.round(l / c),
      m = s / (u + 1 - i),
      d = []
    for (let t = 0; t < u; t++) {
      let a = n + m * t,
        i = n + m * (t + 0.75),
        s = n + m * (t + 1.5),
        l = n + m * (t + 1),
        c = new $e.Vector3(o + Math.cos(a) * e, r + Math.sin(a) * e),
        f = new $e.Vector3(o + Math.cos(i) * e, r + Math.sin(i) * e),
        p = new $e.Vector3(o + Math.cos(s) * e, r + Math.sin(s) * e),
        v = new $e.Vector3(o + Math.cos(l) * e, r + Math.sin(l) * e)
      v.lerp(p, 0.5)
      let g = Math.atan2(c.y - f.y, c.x - f.x),
        h = Math.atan2(p.y - f.y, p.x - f.x)
      d.push(...We(f.distanceTo(c), g, h, 20, f.x, f.y, !0)),
        t < u - 1 && d.push(...We(v.distanceTo(p), h, g, 20, v.x, v.y, !0))
    }
    return d
  }
  function Ue(e, n, t, a, o) {
    let r = new $e.Vector3(e, n),
      i = new $e.Vector3(t, a),
      s = Math.round(r.distanceTo(i) / o / 3),
      l = 20 * s,
      c = 1 / (l - 1),
      u = new $e.Vector3(0, 0, 0)
    u.subVectors(i, r), u.normalize(), (u = new $e.Vector3(-u.y, u.x, 0))
    let m = []
    for (let e = 0; e < l; e++) {
      let n = e * c,
        t = new $e.Vector3()
      t.lerpVectors(r, i, n)
      let a = Math.sin(n * Math.PI * s) * o,
        l = u.clone()
      l.multiplyScalar(a), t.add(l), m.push(t)
    }
    return m
  }
  function qe(e, n, t, a, o) {
    let r = 0.25,
      i = new $e.Vector3(e, n),
      s = new $e.Vector3(t, a).clone().sub(i),
      l = 1.5 * o * 2,
      c = Math.round(s.length() / l),
      u = s.length() / (c + 0.5)
    s.normalize()
    let m = Math.atan2(s.y, s.x),
      d = []
    for (let e = 0; e < c; e++) {
      let n = i.clone().add(s.clone().multiplyScalar((e + 0.75) * u)),
        t = i.clone().add(s.clone().multiplyScalar((e + 1.5 - r) * u))
      d.push(...We(0.75 * u, m + Math.PI, m, 20, n.x, n.y)),
        e < c - 1 && d.push(...We(0.25 * u, m, m - Math.PI, 10, t.x, t.y))
    }
    return d
  }
  function Xe(e, n, t = 10) {
    let a,
      o,
      r,
      i,
      s,
      l = n * (e.length - 1),
      c = Math.floor(l),
      u = l - c
    if (2 == e.length)
      (a = e[0]),
        (o = e[1]),
        (r = o.clone().sub(a).normalize()),
        (s = new $e.Vector3(-r.y, r.x, 0)),
        (i = a.clone().lerp(o, n))
    else {
      let n = c,
        t = c + 1
      ;(a = e[c - 1]), (o = e[n])
      let l = e[t]
      i = o.clone().lerp(l, u)
      let m = o.clone().sub(a).normalize(),
        d = new $e.Vector3(-m.y, m.x, 0),
        f = l.clone().sub(o).normalize(),
        p = new $e.Vector3(-f.y, f.x, 0)
      ;(s = p),
        (r = f),
        0 == u && ((s = p.clone().lerp(d, 0.5)), (r = f.clone().lerp(m, 0.5)))
    }
    let m = -0.5 * t,
      d = i.clone().add(
        s
          .clone()
          .multiplyScalar(m)
          .add(r.clone().multiplyScalar(1.5 * m))
      ),
      f = i.clone().add(
        s
          .clone()
          .multiplyScalar(-m)
          .add(r.clone().multiplyScalar(1.5 * m))
      )
    return [d, i, f]
  }
  function Ge(e, n = 0.006) {
    return Oe(n, 20, 0, e.x, e.y)
  }
  let je = o()
  1 != je.debug >= 1 &&
    (window.console.log = function (e) {
      return 0
    }),
    (THREE.ColorManagement.enabled = !1)
  let Ye = THREE,
    Ke = Math,
    Je = window,
    Qe = /\bHeadlessChrome/.test(navigator.userAgent)
  new (class {
    _rotVel = new c.Vector3()
    _posVel
    _prevMousePos
    _isMouseDown
    constructor() {
      ;(this._posVel = new c.Vector3()),
        (this._prevMousePos = { x: 0, y: 0 }),
        (this._isMouseDown = !1),
        window.addEventListener(
          "touchstart",
          this._mouseDownHandler.bind(this)
        ),
        window.addEventListener("touchend", this._mouseUpHandler.bind(this)),
        window.addEventListener("touchmove", this._mouseMoveHandler.bind(this)),
        window.addEventListener("mousedown", this._mouseDownHandler.bind(this)),
        window.addEventListener("mouseup", this._mouseUpHandler.bind(this)),
        window.addEventListener("mousemove", this._mouseMoveHandler.bind(this)),
        window.addEventListener("wheel", this._mouseWheelHandler.bind(this), {
          passive: !1,
        })
    }
    update(e) {
      e = e || 0.9
      this._posVel.multiplyScalar(e), this._rotVel.multiplyScalar(e)
    }
    getRotationVelocity() {
      return this._rotVel
    }
    getPositionVelocity() {
      return this._posVel
    }
    _mouseDownHandler(e) {
      ;(this._prevMousePos = { x: e.pageX, y: e.pageY }),
        (this._isMouseDown = !0)
    }
    _mouseUpHandler(e) {
      this._isMouseDown = !1
    }
    _mouseMoveHandler(e) {
      if (this._isMouseDown) {
        var n = {
          x: e.pageX - this._prevMousePos.x,
          y: e.pageY - this._prevMousePos.y,
        }
        ;(this._prevMousePos = { x: e.pageX, y: e.pageY }),
          (this._rotVel.x = n.y / 200),
          (this._rotVel.y = n.x / 200)
      }
      e.preventDefault()
    }
    _mouseWheelHandler(e) {
      var n = e.deltaY
      ;(this._posVel.z += n / 5e3), e.preventDefault()
    }
  })()
  let Ze = new Ye.Vector3(L.random_num(-0.6, 0.6), L.random_num(-1, 1), 0),
    en = new Date()
  en.setHours(0),
    en.setMinutes(0),
    en.setSeconds(0),
    en.setMilliseconds(0),
    (en = en.getTime()),
    Ze.normalize()
  window.matchMedia("only screen and (max-width: 1024px)").matches
  let nn,
    tn,
    an,
    on,
    rn,
    sn,
    ln,
    cn,
    un,
    mn,
    dn,
    fn,
    pn,
    vn,
    gn,
    hn,
    xn,
    yn,
    wn,
    Tn = Je.devicePixelRatio ? Je.devicePixelRatio : 1,
    bn = 0,
    zn = 0,
    Pn = { x: 0, y: 0 },
    Rn = { x: 0, y: 0 },
    Sn = !1,
    _n = 0,
    Vn = Yt()
  Kt() && (Vn = 3800)
  let Cn,
    In,
    En,
    Dn,
    Fn,
    Mn,
    Ln,
    An,
    Hn,
    $n,
    On,
    Bn,
    Wn,
    kn,
    Nn,
    Un,
    qn,
    Xn,
    Gn,
    jn,
    Yn,
    Kn,
    Jn,
    Qn,
    Zn,
    et,
    nt,
    tt,
    at = jt(),
    ot = 0,
    rt = 0,
    it = 1,
    st = !1,
    lt = 1,
    ct = -1,
    ut = 15e5,
    mt = Math.ceil(Ke.sqrt(ut)),
    dt = mt,
    ft = !1,
    pt = 1 == je.rddebug,
    vt = !1,
    gt = 0,
    ht = je.bgalpha ? parseFloat(je.bgalpha) : 1,
    xt = { x: 0, y: 0, w: screen.availWidth, h: screen.availHeight },
    yt = screen.isExtended,
    wt = !1,
    Tt = {
      id: -1,
      visibility: 0,
      visibilityTarget: 0,
      shape: new Ye.Vector4(),
      walletsOwner: [],
      isPreLoading: 1,
    },
    bt = {
      id: -1,
      visibility: 0,
      visibilityTarget: 0,
      shape: new Ye.Vector4(),
      walletsOwner: [],
      isPreLoading: 1,
    },
    zt = [],
    Pt = [],
    Rt = [],
    St = 0,
    _t = 0,
    Vt = 1e3,
    Ct = new Ye.Vector2(32, 32),
    It = !1,
    Et = "rotationTimeSynced" + D.resolved(),
    Dt = 0,
    Ft = 0,
    Mt = 0,
    Lt = 0,
    At = 0,
    Ht = !1,
    $t = 0
  console.log("------------------------"),
    console.log("today:", en),
    console.log("time:", Vn),
    console.log("chain:" + S()),
    console.log("owner wallets: " + _()),
    console.log("instanceIndex:" + V),
    console.log("iteration:" + D.actual()),
    console.log("iteration resolved:" + D.resolved()),
    console.log("iteration pair:" + D.pair()),
    console.log("------------------------"),
    2 == je.debug &&
      (console.log("pairs"),
      console.log(JSON.stringify(D.getPairs(), null, 2)),
      console.log("------------------------"),
      console.log("eth main colors"),
      console.log(JSON.stringify(ve(0))),
      console.log("------------------------"),
      console.log("tez main colors"),
      console.log(JSON.stringify(ve(1)))),
    ("1" != je.disableWindowing && "true" != je.disableWindowing) || (Ht = !0),
    Ht &&
      ((Tt.visibilityTarget = 0),
      (bt.visibilityTarget = 0),
      (bt.shape = new Ye.Vector4(10, 10, 0, 0)),
      (window.setWindowShape = function (e, n, t, a, o) {
        ;(1 == e ? bt : Tt).shape = new Ye.Vector4(n, t, a, o)
      }),
      (window.setTopWindow = function (e) {
        $t = e
      }),
      (window.setVisibility = function (e, n) {
        let t = 1 == e ? bt : Tt
        ;(t.id = 0 == n ? -1 : e), (t.visibilityTarget = n)
      }),
      (window.setSameOwner = function (e) {
        _t = e
      }),
      (window.pause = function (e = !0) {
        st = e
      }))
  let Ot = !1
  function Bt() {
    !(function () {
      let e = ge.schemes[V]
      Wn = Xt(e)
      let n = 0 == V ? 1 : 0,
        t = ge.schemes[n]
      kn = Xt(t)
      let a = document.getElementsByTagName("body")[0]
      a.style.background = ht < 1 ? "transparent" : "#" + Wn[0].getHexString()
    })(),
      setTimeout(
        () => {
          ;(Dt = parseFloat(localStorage.getItem(Et)) || 0),
            Ht ||
              (function () {
                ;(On = new Re()),
                  On.setWinShapeChangeCallback(qt),
                  On.setWinChangeCallback(Nt),
                  On.setMetaDataChangeCallback(kt)
                let e = {
                  resolvedIteration: D.resolved(),
                  instanceIndex: V,
                  walletsOwner: _(),
                  isPreLoading: lt,
                  isSphere: !0,
                }
                On.init(e), Nt()
              })(),
            Ut(),
            (function () {
              ;(En = new Ye.OrthographicCamera(0, bn, 0, zn, -1e4, 1e4)),
                (En.position.z = 2.5),
                En.position.z,
                En.position.z,
                (In = new Ye.Scene()),
                In.add(En),
                (Cn = new Ye.WebGLRenderer({
                  antialias: !0,
                  depthBuffer: !0,
                  alpha: ht < 1,
                })),
                Cn.setPixelRatio(Tn),
                Cn.setSize(0, 0),
                Ot &&
                  ((Cn.domElement.style.width = bn / 2 + "px"),
                  (Cn.domElement.style.height = zn / 2 + "px"))
              ;(Dn = new Ye.Object3D()),
                In.add(Dn),
                Cn.domElement.setAttribute("id", "scene"),
                document.body.appendChild(Cn.domElement)
            })(),
            (function () {
              let e = (function () {
                  let e = [],
                    n = { 0: 0, 1: 1, 2: 2, 3: 3 }
                  function t(t, a, o) {
                    n[t.toString()]++, e.push([t, a, ...o])
                  }
                  let a = 0.03,
                    o = 0.015,
                    r = 0.014,
                    i = 0.9 * ge.babyTwinScale,
                    s = ge.babyTwinScale + 0.1,
                    l = ge.spheres[0].contourRadius,
                    c = ge.spheres[1].contourRadius,
                    u = L.random_choice([l, c]),
                    m = [3, 4, 5, 6, 8]
                  s > 0.5 && (m = [3, 6, 8])
                  let d = L.random_choice(m),
                    f = 1
                  d <= 5 && (f = L.random_int(1, 2)),
                    d <= 4 && (f = L.random_int(2, 3))
                  let p = d * f
                  d < 4 && i <= 0.5 && (s = 2 * i)
                  let v = 3
                  s > 0.5 && (v = 3)
                  let g = d + 1
                  ;(g = Math.ceil((u - s) / 0.15)), g < v && (g = v)
                  let h = L.random_int(v, g),
                    x = -0.5 * Math.PI,
                    y = [],
                    w = [],
                    T = (u - s) / (h - 2),
                    b = (2 * Math.PI) / p
                  function z(e, n, a) {
                    for (let o = 0; o < p; o += f) {
                      let r = We(a, x + b * o, x + b * (o + f), 60)
                      L.random_bool(0.5) && t(e, n, r)
                    }
                  }
                  t(2, 0.5, Oe(i, 100)),
                    t(3, 0.5, Oe(i, 100)),
                    z(2, 0.75, i),
                    z(3, 0.75, i)
                  for (let e = 0; e < h; e++) {
                    let n = e
                    e == h - 1 && T < 0.3 && (n += 1)
                    let t = s + T * n
                    y.push(t)
                    let a = Be(t, p, x)
                    w.push(a)
                    for (let e = 0; e < a.length; e++);
                  }
                  let P = w.length - 1
                  P > 3 && (P -= L.random_int(0, 2)), P < 1 && (P = 1)
                  let R = L.random_int(0, 1),
                    S = L.random_num(0, 0.6)
                  console.log("skipProb", S)
                  let _ = (h * d * (1 - S)) / 32
                  for (let e = R; e < P; e++) {
                    let n = w[e]
                    for (let e = 0; e < n.length; e++) {
                      let a = n[e]
                      if (L.random_bool(S)) continue
                      let o = 0
                      o = 1
                      for (let e = 0; e < n.length; e += o) {
                        let o = n[e]
                        ;(a.x == o.x && a.y == o.y) ||
                          t(L.random_int(0, 1), 0.6 - 0.5 * _, [a, o])
                      }
                    }
                  }
                  let V = L.random_int(0, Math.floor(p / 2)),
                    C = L.random_int(-1, w.length),
                    I = L.random_num(0.1, 0.3),
                    E = []
                  for (let e = 0, n = w.length; e < n; e++) {
                    if (e == C && e > 0) {
                      new Array(d).fill(-1)
                      continue
                    }
                    let i = [],
                      s = w[e],
                      l = y[e],
                      c = 1,
                      u = L.random_bool(0.2)
                    e == w.length - 1 && (u = !1),
                      e == w.length - 1 && (c = 0.3),
                      L.random_bool(0.5)
                    let m = !1
                    0 == e && 3 == d && (m = !0), m && (u = !0)
                    let p = -1,
                      v = s.length - f
                    for (let g = 0; g < v; g += f) {
                      if ((3 != d || !u) && L.random_bool(I)) {
                        i.push(-1)
                        continue
                      }
                      let v = L.random_int(0, 1),
                        h = L.random_bool(0.4)
                      0 == e && 3 == d && (h = !1), new Array(V).fill(-1)
                      let y = L.random_choice([0, 0, 0, 0, 1, 1, 2])
                      e >= n - 2 && (y = 0),
                        m && ((u = !0), (y = 0)),
                        ((3 == d && u) || p > 0) && (y = 0),
                        0 == e && u && (y = 0)
                      let w = s[g],
                        T = g < s.length - f ? s[g + f] : s[0]
                      if (((p = y), i.push(y), u))
                        switch (y) {
                          case 0: {
                            let e = [w, T]
                            t(v, c, e), h && t(v, c, Xe(e, 0.5, a))
                            break
                          }
                          case 1:
                            t(v, c, Ue(w.x, w.y, T.x, T.y, o))
                            break
                          case 2:
                            t(v, c, qe(w.x, w.y, T.x, T.y, 0.0182))
                        }
                      else
                        switch (y) {
                          case 0: {
                            let e = We(l, x + b * g, x + b * (g + f), 60)
                            t(v, c, e), h && t(v, c, Xe(e, 0.5, a))
                            break
                          }
                          case 1:
                            t(v, c, ke(l, x + b * g, x + b * (g + f), o))
                            break
                          case 2:
                            t(v, c, Ne(l, x + b * g, x + b * (g + f), r))
                        }
                    }
                    E.push(i)
                  }
                  for (let e = 0; e < E.length; e++) {
                    let n = w[e],
                      r = w[e + 1],
                      i = 0,
                      s = 0
                    for (let l = 0, c = n.length; l < c; l += f) {
                      let c = E[e][s]
                      E[e][s + 1]
                      let u = E[e][s - 1]
                      s++
                      let m = l,
                        d = l
                      function f(n, r, s) {
                        let l = [n, r]
                        new Array(V).fill(-1)
                        let c = L.random_choice([0, 0, 0, 0, 1, 1, 2])
                        switch (
                          (s > 0 && (c = 0),
                          e == w.length - 2 && (c = 0),
                          0 == c && L.random_bool(0.5) && (l = [l[1], l[0]]),
                          c)
                        ) {
                          case 0:
                            t(i, 1, [n, r]),
                              (e == w.length - 2 || L.random_bool(0.5)) &&
                                t(i, 1, Xe(l, 0.5, a))
                            break
                          case 1:
                            t(i, 1, Ue(n.x, n.y, r.x, r.y, o))
                            break
                          case 2:
                            t(i, 1, qe(n.x, n.y, r.x, r.y, 0.0182))
                        }
                        t(i, 1, Ge(n)), t(i, 1, Ge(r))
                      }
                      ;(i = L.random_int(0, 1)),
                        L.random_bool(0.2) && (i += 2),
                        c > -1
                          ? (e < w.length - 1 &&
                              L.random_bool(0.5) &&
                              f(n[m], r[d], c),
                            (u > -1 || 0 == l) && t(i, 1, Ge(n[l])))
                          : u > -1 && t(i, 1, Ge(n[l]))
                    }
                  }
                  return e
                })(),
                n = [],
                a = 0,
                o = new Ye.LineBasicMaterial({
                  color: 16711680,
                  transparent: !0,
                  opacity: 0.3,
                }),
                r = new Ye.Object3D(),
                i = 0
              for (let t = 0; t < e.length; t++) {
                let s = [...e[t]],
                  l = s.splice(0, 2)[1]
                s.length > i && (i = s.length)
                let c = new Ye.BufferGeometry().setFromPoints(s)
                r.add(new Ye.Line(c, o))
                let u = s,
                  m = 0
                for (let e = 1; e < u.length; e++) {
                  let n = u[e - 1],
                    t = u[e]
                  m += n.clone().distanceTo(t) * l
                }
                ;(a += m), n.push(m)
              }
              let s = [],
                l = 1e3,
                c = []
              for (let o = 0; o < e.length; o++) {
                let r = e[o],
                  u = r.splice(0, 2),
                  m = u[0],
                  d = u[1],
                  f = n[o] * d,
                  p = f / a
                ;(p = t(p, 0, 1)), (p = 1 - Math.pow(1 - p, 2))
                const v = Math.ceil(l * (p * d))
                let g = new Array(v)
                g.fill(o), c.push(...g)
                let h = new Ye.Vector3(r.length, f, m)
                s.push(h)
                for (let e = 0; e < i; e++) {
                  let n
                  ;(n = e < r.length ? r[e] : new Ye.Vector3()), s.push(n)
                }
              }
              ;(Jn = a),
                (et = c.length),
                (Qn = e.length),
                (Zn = i),
                (Kn = Gt(s, i + 1, e.length))
              let u = Math.ceil(Math.sqrt(c.length))
              ;(nt = (function (e, n, t) {
                let a = new Float32Array(n * t * 4)
                for (let n = 0; n < e.length; n++) {
                  const t = 4 * n
                  ;(a[t] = e[n]), (a[t + 1] = 0), (a[t + 2] = 0), (a[t + 3] = 0)
                }
                let o = new THREE.DataTexture(
                  a,
                  n,
                  t,
                  THREE.RGBAFormat,
                  THREE.FloatType
                )
                return (o.needsUpdate = !0), o
              })(c, u, u)),
                (tt = new Ye.Vector2(u, u)),
                (r.position.x = 0.5 * window.innerWidth),
                (r.position.y = 0.5 * window.innerHeight),
                (r.scale.x = r.scale.y = 200)
            })(),
            (jn = new He(Cn, Dn, D.resolved(), ge.rd, Vt, !1, pt)),
            (function () {
              ;(nn = new l(mt, dt, Cn)),
                (hn = nn.createTexture()),
                (xn = nn.addVariable(
                  "texturePolarAcc",
                  `\nuniform int frame;\nuniform float time;\n${f}\n${d}\n${u}\nvoid main () \n{\nfloat nPoints = resolution.x * resolution.y;\nfloat i = (gl_FragCoord.y * resolution.x) + gl_FragCoord.x;\nvec2 uv = gl_FragCoord.xy / resolution.xy;\nvec4 pPos = texture2D(texturePolarPos, uv);\nvec3 acc = vec3(0.0);\ngl_FragColor = vec4(acc.xyz, 1.0);\n}`,
                  hn
                )),
                (xn.material.uniforms.frame = { value: 0 }),
                (xn.material.uniforms.time = { value: 0 }),
                (vn = nn.createTexture()),
                (gn = nn.addVariable(
                  "texturePolarVel",
                  `\nuniform int frame;\nuniform float time;\n${f}\n${d}\nvoid main () \n{\nfloat nPoints = resolution.x * resolution.y;\nfloat i = (gl_FragCoord.y * resolution.x) + gl_FragCoord.x;\nvec2 uv = gl_FragCoord.xy / resolution.xy;\nvec4 pVel = texture2D(texturePolarVel, uv);\nvec4 pAcc = texture2D(texturePolarAcc, uv);\nvec3 vel = vec3(0.0);\nif (frame > 0)\n{\nvel = pVel.xyz + pAcc.xyz; \n}\nvel *= .9;\ngl_FragColor = vec4(vel.xyz, 1.0);\n}`,
                  vn
                )),
                (gn.material.uniforms.frame = { value: 0 }),
                (gn.material.uniforms.time = { value: 0 }),
                (fn = nn.createTexture()),
                (pn = nn.addVariable(
                  "texturePolarPos",
                  `\nuniform int frame;\nuniform float time;\n${f}\n${d}\n${u}\nvoid main () \n{\nfloat nPoints = resolution.x * resolution.y;\nfloat i = (gl_FragCoord.y * resolution.x) + gl_FragCoord.x;\nvec2 uv = gl_FragCoord.xy / resolution.xy;\nvec4 prevPos = texture2D(texturePolarPos, uv);\nvec4 pVel = texture2D(texturePolarVel, uv);\nvec3 pos;\nif (frame == 0)\n{\npos.y = hash12(uv * 100.0) * PI * 2.0;\npos.z = hash12(uv * 400.0) * PI * 2.0;\n}\nelse\n{\npos = prevPos.xyz+ pVel.xyz;\n}\ngl_FragColor = vec4(pos.xyz, 1.0);\n}`,
                  fn
                )),
                (pn.material.uniforms.frame = { value: 0 }),
                (pn.material.uniforms.time = { value: 0 }),
                (mn = nn.createTexture()),
                (dn = nn.addVariable(
                  "texturePositionTarget",
                  `\nuniform float time;\nuniform float rotationTime;\nuniform int frame;\nuniform vec4 instanceShape[2];\nuniform float instanceVis[2];\nuniform vec4 unpairedShapes[10];\nuniform int numUnpaired;\nuniform int numRdPolyVerts;\nuniform int isPreLoading;\nuniform int isPreview;\nuniform int isSameOwner;\nuniform float sphereRadius;\nuniform int instanceIndex;\nuniform float mergeTransition;\nuniform float diagramVisibility;\nuniform sampler2D rdPolyTex;\nuniform sampler2D rdTex;\nuniform sampler2D diagramTex;\nuniform sampler2D diagramIndexBinsTex;\nuniform ivec2 rdPolyTexSize;\nuniform ivec2 diagramIndexBinsTexSize;\nuniform int diagramNumIndexBins;\nuniform int diagramNumLines;\nuniform int diagramMaxVerts;\nuniform float diagramTotalLength;\n${be.getUniformsString()}\n${f}\n${u}\n${m}\n${d}\n${p}\n\nvec3 polarToCartesian (vec3 p)\n{\nfloat y = atan(p.z, p.x);\nfloat z = atan(p.y, sqrt(pow(p.x, 2.0) + pow(p.z, 2.0)));\nreturn vec3(0.0, y, z);\n}\n\nvec3 cartesianToPolar (vec3 p)\n{\nvec3 p2;\np2.x = cos(p.z);\np2.y = sin(p.z);\np2.z = sin(p.y) * p2.x;\np2.x = cos(p.y) * p2.x;\nreturn p2;\n}\n${we}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\nreturn min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n${v}\n${g}\nvec2 rotate(vec2 v, float a)\n{\nfloat s = sin(a);\nfloat c = cos(a);\nmat2 m = mat2(c, s, -s, c);\nreturn m * v;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\nreturn length(max(abs(p)-b,0.0));\n}\nfloat sdOctahedron( vec3 p, float s )\n{\np = abs(p);\nfloat m = p.x+p.y+p.z-s;\nvec3 q;\nif( 3.0*p.x < m ) q = p.xyz;\nelse if( 3.0*p.y < m ) q = p.yzx;\nelse if( 3.0*p.z < m ) q = p.zxy;\nelse return m*0.57735027;\nfloat k = clamp(0.5*(q.z-q.y+s),0.0,s); \nreturn length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#define sabs(p) sqrt((p)*(p)+2e-3)\n#define smin(a,b) (a+b-sabs(a-b))*.5\n#define smax(a,b) (a+b+sabs(a-b))*.5\nfloat sdIcosa(vec3 p,float r)\n{\nfloat G=sqrt(5.)*.5+.5;\nvec3 n=normalize(vec3(G,1./G,0));\nfloat d=0.;\np=sabs(p);\nd=smax(d,dot(p,n));\nd=smax(d,dot(p,n.yzx));\nd=smax(d,dot(p,n.zxy));\nd=smax(d,dot(p,normalize(vec3(1))));\nreturn d-r;\n}\nvoid main ()\n{\nvec4 pos;\nvec2 uv = gl_FragCoord.xy / resolution.xy;\nvec4 acc = texture2D(textureAcc, uv);\nfloat nPoints = resolution.x * resolution.y;\nfloat i = (gl_FragCoord.y * resolution.x) + gl_FragCoord.x;\nfloat iRat = (i / nPoints);\nfloat t = iRat + sin(i) + cos(i * 0.5);\nint index = 0;\nif (iRat > .5) index = 1;\nbool isBabyTwin = sin(iRat * PI * 4.0)  > 0.0;\nfloat oThresh = (1.0 + sin(i)) / 2.0;\nint mType0 = ${ge.motionType0};\nint mType1 = ${ge.motionType1};\nint behaviourType = isBabyTwin ? mType0 : mType1;\nbehaviourType = ${ge.invertMotiontype ? "mType0" : "isBabyTwin ? mType0 : mType1"};\nfloat outerProb = ${ge.spheres[0].outerLayerProb.toPrecision(5)};\nfloat radius = sphereRadius;\nfloat outerNoiseOffset = ${ge.spheres[0].outerNoiseOffset.toPrecision(5)};\nfloat outerNoiseScale = ${ge.spheres[0].outerNoiseScale.toPrecision(5)};\nfloat outerOffset = ${ge.spheres[0].outerOffset.toPrecision(5)};\nfloat contourVisibility = ${ge.spheres[0].contourVisibility.toPrecision(7)};\nfloat contourRadius = ${ge.spheres[0].contourRadius.toPrecision(7)};\nint babyTwinType = ${ge.babyTwinType};\nif (index == 1)\n{\nbehaviourType = ${ge.invertMotiontype ? "mType1" : "isBabyTwin ? mType0 : mType1"};\nouterProb = ${ge.spheres[1].outerLayerProb.toPrecision(5)};\nouterNoiseOffset = ${ge.spheres[1].outerNoiseOffset.toPrecision(5)};\nouterNoiseScale = ${ge.spheres[1].outerNoiseScale.toPrecision(5)};\nouterOffset = ${ge.spheres[1].outerOffset.toPrecision(5)};\ncontourVisibility = ${ge.spheres[1].contourVisibility.toPrecision(7)};\ncontourRadius = ${ge.spheres[1].contourRadius.toPrecision(7)};\n}\nvec4 w = instanceShape[0];\nvec4 w2 = instanceShape[1];\nvec2 _c0 = vec2(w.x + w.z *.5, w.y + w.w * .5);\nvec2 _c1 = vec2(w2.x + w2.z * .5, w2.y + w2.w * .5);\nvec2 _c0copy = _c0;\n_c0 = mix(_c0, _c1,  mergeTransition * .5);\n_c1 = mix(_c1, _c0copy, mergeTransition * .5);\nint index2 = index == 0 ? 1 : 0;\nw = instanceShape[index];\nw2 = instanceShape[index2];\nvec2 c0 = index == 0 ? _c0 : _c1;\nvec2 c1 = index2 == 0 ? _c0 : _c1;\nfloat distance = length(c0 - c1);\nif (w.z <= 0.0 || w2.z <= 0.0) distance = 1000000.0;\nfloat distanceRat = clamp(distance / (radius * 5.0), 0.0, 1.0);\nfloat mergeRat = clamp((distance - sphereRadius) / (sphereRadius * 1.0), 0.0, 1.0);\nfloat mergeRat2 = clamp((distance - sphereRadius * 2.0) / (sphereRadius * 2.0), 0.0, 1.0);\nif(!isBabyTwin)\n{\nfloat mrat = clamp((distance - (sphereRadius * .3)) / (sphereRadius * .3), 0.0, 1.0);\nfloat upscale = (pow(1.0 - mrat, 3.0));\nfloat scale = .1;\nif (isSameOwner == 1) scale *= 2.0;\nradius *= 1.0 + (upscale * float(index) * .2);\nouterNoiseOffset += upscale * .25;\n}\nouterOffset *= radius * .5;\nouterNoiseOffset *= radius * 7.5;\nbool isOuterLayer = (!isBabyTwin && oThresh < outerProb);\nbool isConnection = isBabyTwin && sin(i * 0.1) > 0.0;\nfloat nScale = noiseScale;\nfloat nTime = time * speed;\nfloat nZ = 0.0;\nfloat off = 0.0;\nfloat yRot;\nfloat zRot;\nif (!isOuterLayer && (behaviourType == 2 || behaviourType == 0) && (1.0 + sin(i * 1.33)) / 2.0 > (1.0 - contourVisibility))\n{\nbehaviourType = 1;\nradius *= contourRadius;\n}\nif (isPreview == 1 && isPreLoading == 1)\n{\nbehaviourType = 1;\n}\nif (isPreLoading == 1 && isPreview == 0)\n{\nfloat numMovers = 100.0;\nfloat moverOffset = (floor(iRat * numMovers) / numMovers);\nmoverOffset += hash12(vec2(i, 0.0)) * 0.002;\nyRot = moverOffset * PI * 10.0 + sin((iRat - moverOffset * .3) * PI * 1.0);\nzRot = (time * 3.1) + ((iRat - (moverOffset * .0)) * PI * 50.0) + moverOffset;\nyRot += cnoise(vec3(iRat * 10.0, 0.0, 0.0)) * 10.0;\nzRot += cnoise(vec3(iRat * 5.0, 0.0, 0.0)) * 10.0;\nzRot += cnoise(vec3(zRot * curlSize1, yRot * curlSize1, time * .1)) * curlStrength1;\nradius = 10.0 + moverOffset * 10.0;\nradius += sin(iRat + (time * 6.0)) * 7.5;\nouterOffset *= .1;\nouterNoiseOffset *= .1;\n}\nelse if (behaviourType == 0)\n{\nfloat i2 = i;\nif (isOuterLayer) i2 -= 5.0;\nfloat pInd = floor(i2 / 10000.0);\nfloat rat = (i2 - pInd * 10000.0);\nrat *= .003 * hash12(vec2(pInd, pInd));\nyRot = nTime * (0.02 + (pInd * nIndexMultiplier1)) + rat;\nzRot = nTime * (0.06 + (pInd * nIndexMultiplier1)) + rat;\nif (extraSin == 1)\n{\nyRot = sin(yRot) * PI * nRevolutions1 + off;\nzRot = cos(zRot) * PI * nRevolutions1 + off;\n}\nfloat b = hash12(uv * 123.4) * blur;\nif ((((1.0 + sin(i2)) / 2.0) > blurRatio)) b *= 0.0;\nfloat off = ${L.random_num(0, 2e3).toPrecision(5)};\nyRot = cnoise(vec3(yRot * nScale, off, pInd * nIndexMultiplier2 + b)) * PI * nRevolutions2;\nzRot = cnoise(vec3(zRot * nScale, off, pInd * nIndexMultiplier2 + b)) * PI * nRevolutions2;\noff = ${L.random_num(0, 2e3).toPrecision(5)} + (float(index) * .5);\nyRot += cnoise(vec3(yRot * curlSize1, zRot * curlSize1, off)) * curlStrength1;\nzRot += cnoise(vec3(zRot * curlSize1, yRot * curlSize1, off)) * curlStrength1;\n}\nelse if (behaviourType == 1)\n{\nvec4 polPos = texture2D(texturePolarPos, uv);\nyRot = polPos.y;\nzRot = polPos.z;\nyRot += time * hash12(uv) * .1;\nzRot += time * hash12(uv + 123.4) * .1;\n}\nelse if (behaviourType == 2)\n{\nfloat extent = .5 + (.5 * (float(index)));\nextent = .9;\nfloat iRat2 = iRat * extent;\nfloat numMovers = 100.0;\nfloat moverOffset = (floor(iRat2 * numMovers) / numMovers);\nfloat speed = 0.005 + (moverOffset * 0.005);\nspeed += sin(iRat2) * 0.0001;\nfloat rat = (time * speed);\nrat += .5 * float(index);\nfloat moverLength = (1.0 / numMovers) * 3.;\nfloat moverLengthRat = (iRat2 - moverOffset) / (1.0 / numMovers);\nfloat numLayers = 105.0;\nmoverLengthRat *= numLayers;\nfloat layerOffset = moverLengthRat / numLayers;\nrat += moverOffset + mod(moverLengthRat, 1.0) * moverLength;\nrat = mod(rat, 1.0);\nfloat pIndex = rat * float(numRdPolyVerts);\nint pIndexI = int(floor(pIndex));\nfloat ratio2 = pIndex - float(pIndexI);\nvec3 p1 = texture2DAtIndex(rdPolyTex, pIndexI, rdPolyTexSize).xyz;\nvec3 p2 = texture2DAtIndex(rdPolyTex, pIndexI+1, rdPolyTexSize).xyz;\npos.xyz = mix(p1, p2, ratio2);\nyRot = atan(pos.z, pos.x);\nzRot = atan(pos.y, sqrt(pow(pos.x, 2.0) + pow(pos.z, 2.0)));\nfloat nScale = 0.02;\nfloat n = cnoise(pos.xyz * nScale + vec3(0.0, 0.0, time * .01));\nfloat n2 = cnoise((pos.xyz + 123.45) * nScale + vec3(0.0, 0.0, time * .01));\nfloat s = pow(sin(iRat * PI * 123444.0), 5.0) * .2;\ns = pow(layerOffset, 3.0) * 2.0;\ns += pow(hash12(vec2(layerOffset, 0.0)), 20.0) * PI * 1.0;\ns += pow(hash12(vec2(i, layerOffset)), 20.0) * .5;\nyRot += n * s;\nzRot += n2 * s;\n}\nvec2 uv2 = uvFromPolar(vec3(0.0, yRot, zRot));\nvec4 rd = texture2D(rdTex, uv2);\nif (isPreLoading != 1 && behaviourType == 1) radius += pow(rd.g, 3.0) * 1200.0 * ${ge.bumpMapSize.toPrecision(5)};\nvec3 p2;\np2.x = cos(zRot);\np2.y = sin(zRot);\np2.z = sin(yRot) * p2.x;\np2.x = cos(yRot) * p2.x;\nvec3 deformPos = (p2 + ${L.random_num(0, 2e3).toPrecision(5)} * float(index)) * ${1.5 * ge.deformNoiseScale};\nfloat deform =  (1.0 - pow(1.0 - cnoise(deformPos), 2.0)) * 1.0;\ndeform = clamp(deform, 0.0, 1.0);\ndeform = smoothstep(0.0, 1.0, deform);\ndeform *= sphereRadius * .5;\nif (isBabyTwin) radius += deform * ${ge.deformCoreStrength.toPrecision(5)};\nelse radius += deform * ${ge.deformMainStrength.toPrecision(5)};\nif (isOuterLayer)\n{\nradius += outerOffset;\nfloat s = outerNoiseScale;\nfloat add = (1.0 + cnoise(vec3(yRot * s, zRot * s, time * .1))) / 2.0;\nadd = pow(add, 4.0);\nradius += add * outerNoiseOffset;\n}\npos.x = cos(zRot) * radius;\npos.y = sin(zRot) * radius;\npos.z = sin(yRot) * pos.x;\npos.x = cos(yRot) * pos.x;\nif (isPreLoading != 1 && isBabyTwin && babyTwinType > 0)\n{\nfloat dist;\nif (babyTwinType == 1)\n{\ndist = sdIcosa(pos.xyz, radius * .7);\n}\nelse if (babyTwinType == 2)\n{\ndist = sdBox((pos * rotationMatrix(vec3(0.0, 0.0, 1.0), PI * .25)).xyz, vec3(radius*.5));\n}\nelse if (babyTwinType == 3)\n{\ndist = sdOctahedron(pos.xyz, radius * .9);\n}\nradius -= dist;\npos.x = cos(zRot) * radius;\npos.y = sin(zRot) * radius;\npos.z = sin(yRot) * pos.x;\npos.x = cos(yRot) * pos.x;\n}\nif (${1 == ge.mainType} && isPreLoading != 1)\n{\nfloat dist = sdIcosa(pos.xyz, radius);\nradius -= dist;\npos.x = cos(zRot) * radius;\npos.y = sin(zRot) * radius;\npos.z = sin(yRot) * pos.x;\npos.x = cos(yRot) * pos.x;\n}\nvec3 rot;\nrot.y = time * 1.5 * ${ge.rotationSpeedY.toPrecision(5)};\nrot.z = time * 1.5 * ${ge.rotationSpeedZ.toPrecision(5)};\nfloat dir = index >= 1 ? -1.0 : 1.0;\nif (${ge.flipRotation}) rot.z *= dir;\nmat4 rotation = rotationMatrix(vec3(0.0, 1.0, 0.0), rot.y);\nmat4 rotation2 = rotationMatrix(vec3(0.0, 0.0, 1.0), rot.z);\nif ((isBabyTwin && ${ge.rotateCoreZ}) || !isBabyTwin) rotation *= rotation2;\npos *= rotation;\nvec4 pos2 = pos;\nvec3 offset = vec3(c0.xy, 0.0);\npos.xyz += offset;\nfloat vis = clamp(instanceVis[index] * 3.0, 0.0, 1.0);\nif (isBabyTwin)\n{\nfloat iVis2 = instanceVis[index2];\nfloat tOffset = pow(hash12(uv.xy * 234.4), 1.0) * 3.0;\niVis2 = clamp(-tOffset + ((1.0 + tOffset) * iVis2), 0.0, 1.0);\nvis = clamp(instanceVis[index] * 2.0, 0.0, 1.0) * iVis2;\nvec3 offset2 = vec3(c1, 0.0);\nfloat mrat = clamp((distance - (sphereRadius * .3)) / (sphereRadius * .3), 0.0, 1.0);\nfloat bRat = 1.0 - pow(1.0 - mrat, 3.0);\nfloat toScale = ${ge.babyTwinScale} * instanceVis[index2];\nfloat fromScale = 1.0 + (.3 * iVis2);\nfloat s = -.2 + float(index) * .2;\nfromScale = mix(toScale * (1.0 + s), fromScale, bRat);\ntoScale = mix(toScale * (1.0 + s), toScale , bRat);\nif (isConnection)\n{\nisBabyTwin = false;\nvis = clamp(instanceVis[index] * 1.0, 0.0, 1.0);\nfloat speed = .2 + (sin(i) * .1);\nfloat rat = (1.0 + sin(time * speed + iRat * 234.0)) / 2.0;\nrat *= iVis2;\nmrat = clamp((distance - (sphereRadius * .5)) / (sphereRadius * .5), 0.0, 1.0);\nrat *= pow(mrat, 2.0);\nfloat rat2 = pow(abs(rat - .5) * 2.0, 2.0 + (distanceRat * .5));\ntoScale = mix(fromScale, toScale, rat);\nfloat thickness = .1 + ((1.0 - distanceRat) * .9);\nthickness *= .3 - (float(index) * .1);\nthickness *= 1.0 - .6 * clamp(connectionTwists, 0.0, 1.0);\ntoScale *= thickness + (rat2 * (1.0 - thickness));\noffset2 = mix(offset, offset2, rat);\nfloat s = 50.0 + 80.0 * (1.0 - distanceRat);\nfloat cRat = sin(rat * PI * 1.0);\nfloat cRat2 = abs(-.5 + cRat) * 2.0;\ncRat2 = 1.3 - pow(cRat, 1.0);\nvec3 rotCenter = offset2;\noffset2.y += ((-s*.5) + s * float(index)) * cRat * cRat2 * clamp(connectionTwists, 0.0, 1.0);\nvec3 axis = offset2 - offset;\nif (length(axis) > 0.0)\n{\naxis = normalize(axis);\nmat4 twistMat = rotationMatrix(axis, rat * PI * connectionTwists);\noffset2 = rotCenter + (vec4(offset2 - rotCenter, 0.0) * twistMat).xyz;\n}\ntoScale *= ${L.random_bool()} ? .5 : 1.0;\nif (isSameOwner == 1)\n{\nfloat mrat = clamp((distance - (sphereRadius * .3)) / (sphereRadius * .3), 0.0, 1.0);\nmrat = 1.0 - pow(mrat, 3.0);\nfloat subTract = 0.0;\nsubTract = ${L.random_bool(0.5)} ? .5 : 0.0;\nsubTract = mix(subTract, 0.0, mrat);\ntoScale *= 1.0 + (cnoise(vec3(pos2.x * .004, pos2.y * .004, time * .2 + float(index)))) * 2.5 * mrat;\ntoScale *= 1.0 + pow((cnoise(vec3(pos2.x * .8, pos2.y * .8, time * 1000.0))), 5.0) * sphereRadius * 2.5 * mrat;\nvis *= 1.0 - (mergeTransition * .5);\n}\n}\npos2.xyz *= toScale;\npos2.xyz += offset2;\npos = pos2;\n}\nfloat type = 0.0;\nif (isOuterLayer) type = 1.0;\nif (isBabyTwin) type = 2.0;\nif (isConnection) type = 3.0;\nfloat dThresh = diagramTotalLength / 250.0;\ndThresh = diagramTotalLength / 400.0;\nfloat mrat = clamp((distance - (sphereRadius * .3)) / (sphereRadius * .3), 0.0, 1.0);\nif (!isConnection && !isBabyTwin && !isOuterLayer && hash12(uv * 23.3) < dThresh)\n{\ntype = 4.0;\nint nPolys = diagramNumLines;\nint maxVerts = diagramMaxVerts;\nfloat lineIndex = floor(hash12(uv * 4.5) * float(diagramNumIndexBins+1));\nlineIndex = texture2DAtIndex(diagramIndexBinsTex, int(lineIndex), diagramIndexBinsTexSize).r;\nvec2 uv = vec2(0.0);\nuv.y =  lineIndex / (float(nPolys) - 0.001);\nvec3 data = texture2D(diagramTex, uv).xyz;\nfloat dInd = data.z;\nint iInd = int(dInd);\nbool alwaysVis = false;\nif (dInd >= 2.0)\n{\niInd = int(dInd - 2.0);\nalwaysVis = true;\n}\nfloat lineSpeed = .03 + (.5 * (1.0 - clamp(data.y, 0.0, 1.0)));\nfloat rat = (1.0 + sin((iRat * 100.0) + time * lineSpeed)) / 2.0;\nrat = clamp(rat, 0.0, 1.0);\nrat *= data.x-1.0;\nfloat ind = floor(rat);\nrat -= ind;\nind += 1.0;\nuv.x = (ind - 0.0001) / (float(maxVerts) - 1.0);\nvec3 p0 = texture2D(diagramTex, uv).xyz;\nuv.x = (ind - 0.0001 + 1.0) / (float(maxVerts) - 1.0);\nvec3 p1 = texture2D(diagramTex, uv).xyz;\npos.xyz = mix(p0, p1, rat);\nmat4 rotation2 = rotationMatrix(vec3(0.0, 0.0, 1.0), (time * ${ge.rotationSpeedDiagram.toPrecision(5)} * 1.5));\npos *= rotation2;\npos *= sphereRadius;\nvec2 c = iInd == 0 ? _c0 : _c1;\nvec3 offset = vec3(c, 0.0);\npos.xyz += offset.xyz;\nif (hash12(vec2(uv.x * 123.3 + time, uv.y* 455.4) + time) > .3)\n{\nfloat s = .002;\nfloat t = time * .1;\nfloat size = cnoise(vec3(pos.x * .05, pos.y * .05, time * .5));\nfloat v = cnoise(vec3((pos.x * s) + t, (pos.y * s) + t, pos.z * s));\nv = pow(v, 2.0) * 1.0;\nif (!alwaysVis)\n{\nv += (1.0 - diagramVisibility) * .07;\nif (isSameOwner == 1) v *= .9 + (.1 * (1.0 - mergeTransition));\n}\npos.x += pow(hash12(pos.xy * .2 + time), 100.0) * 100000.0 * size * v;\npos.y += pow(hash12(pos.xy * .4 + time), 100.0) * 100000.0 * size * v;\n}\nindex = iInd;\nfloat s = .002;\nfloat t = time * .1;\nvis = 0.0;\nif (iInd == 1) vis = instanceVis[1];\nif (iInd == 0) vis = instanceVis[0];\nif (!alwaysVis) vis *= .3 + (.7 * diagramVisibility);\n}\npos.w = vis;\npos.w += float(index * 10);\npos.w += type * 100.0;\ngl_FragColor = pos;\n}`,
                  mn
                )),
                (dn.material.uniforms.instanceIndex = { value: V }),
                (dn.material.uniforms.time = { value: 0 }),
                (dn.material.uniforms.sphereRadius = { value: 200 }),
                (dn.material.uniforms.rotationTime = { value: Dt }),
                (dn.material.uniforms.frame = { value: 0 }),
                (dn.material.uniforms.instanceShape = {
                  value: [new Ye.Vector4(), new Ye.Vector4()],
                }),
                (dn.material.uniforms.instanceVis = { value: [0, 0] }),
                (dn.material.uniforms.numRdPolyVerts = { value: Vt }),
                (dn.material.uniforms.diagramTex = { value: Kn }),
                (dn.material.uniforms.diagramNumLines = { value: Qn }),
                (dn.material.uniforms.diagramMaxVerts = { value: Zn }),
                (dn.material.uniforms.isPreLoading = { value: lt }),
                (dn.material.uniforms.isSameOwner = { value: _t }),
                (dn.material.uniforms.isPreview = { value: Kt() ? 1 : 0 }),
                (dn.material.uniforms.rdTex = { value: jn.getTexture() }),
                (dn.material.uniforms.rdPolyTex = { value: jn.getTexture() }),
                (dn.material.uniforms.rdPolyTexSize = { value: Ct }),
                (dn.material.uniforms.diagramIndexBinsTex = { value: nt }),
                (dn.material.uniforms.diagramIndexBinsTexSize = { value: tt }),
                (dn.material.uniforms.diagramNumIndexBins = { value: et }),
                (dn.material.uniforms.diagramTotalLength = { value: Jn }),
                (dn.material.uniforms.unpairedShapes = { value: Pt }),
                (dn.material.uniforms.numUnpaired = { value: St }),
                (dn.material.uniforms.mergeTransition = { value: Ft }),
                (dn.material.uniforms.diagramVisibility = { value: Lt }),
                be.injectUniforms(dn.material.uniforms),
                (yn = nn.createTexture()),
                (wn = nn.addVariable(
                  "textureColor",
                  "\nuniform float mergeTransition;\nuniform int isSameOwner;\nvoid main ()\n{\nvec2 uv = gl_FragCoord.xy / resolution.xy;\nvec4 posTarget = texture2D(texturePositionTarget, uv);\nfloat type = floor(posTarget.w / 100.0);\nint iType = int(type);\nposTarget.w -= type * 100.0;\nint colInd = int(floor((posTarget.w) / 10.0));\nposTarget.w -= float(colInd) * 10.0;\nfloat vis = posTarget.w; \nvec4 c = vec4(1.0, 0.0, 0.0, 0.0);\nif (colInd == 1) c = vec4(0.0, 1.0, 0.0, 0.0);\nif (isSameOwner == 1)\n{\nvec4 c2 = vec4(0.0, 1.0, 0.0, 0.0);\nif (iType >= 2) c2 = vec4(1.0, 0.0, 0.0, 0.0);\nc = mix(c, c2, mergeTransition);\n}\nc.z = type;\nc.w = vis;\ngl_FragColor = c;\n}",
                  yn
                )),
                (wn.material.uniforms.mergeTransition = { value: Ft }),
                (wn.material.uniforms.isSameOwner = { value: _t }),
                (sn = nn.createTexture()),
                (ln = nn.addVariable(
                  "texturePosition",
                  `\nuniform float time;\nuniform int frame;\nuniform int resetQuadrantIndex;\nuniform vec2 canvasSize;\nuniform float scale;\nuniform vec3 offset;\nuniform int isPreLoading;\nuniform int isPreview;\nuniform int preLoadingStoppedAtFrame;\n${f}\n${u}\nvoid main () \n{\nvec2 uv = gl_FragCoord.xy / resolution.xy;\nvec3 pos = texture2D(texturePosition, uv).xyz;\nvec3 posTarget = texture2D(texturePositionTarget, uv).xyz;\nvec4 vel = texture2D(textureVel, uv);\nfloat nPoints = resolution.x * resolution.y;\nfloat i = (gl_FragCoord.y * resolution.x) + gl_FragCoord.x;\nif (isPreview == 1 || (isPreview == 0 && frame < 2))\n{\npos = posTarget;\n}\nelse\n{\npos += vel.xyz;\n}\ngl_FragColor = vec4(pos.xyz, vel.w);\n}`,
                  sn
                )),
                (ln.material.uniforms.time = { value: 0 }),
                (ln.material.uniforms.frame = { value: 0 }),
                (ln.material.uniforms.canvasSize = {
                  value: new Ye.Vector2(bn, zn),
                }),
                (ln.material.uniforms.offset = { value: new Ye.Vector3() }),
                (ln.material.uniforms.scale = { value: 1 }),
                (ln.material.uniforms.isPreLoading = { value: lt }),
                (ln.material.uniforms.isPreview = { value: Kt() ? 1 : 0 }),
                (ln.material.uniforms.preLoadingStoppedAtFrame = { value: ct }),
                (cn = nn.createTexture()),
                (un = nn.addVariable(
                  "texturePosition2",
                  `\nuniform float time;\nuniform int frame;\nuniform int resetQuadrantIndex;\nuniform vec2 canvasSize;\nuniform float scale;\nuniform vec3 offset;\n${f}\n${u}\nvoid main () \n{\nvec2 uv = gl_FragCoord.xy / resolution.xy;\nvec3 pos = texture2D(texturePosition, uv).xyz;\nvec4 vel = texture2D(textureVel, uv);\nfloat nPoints = resolution.x * resolution.y;\nfloat i = (gl_FragCoord.y * resolution.x) + gl_FragCoord.x;\nfloat iRat = (i / nPoints);\nif (false)\n{\nfloat sc = 1.0;\nif (int(i) % 6 == 0)\n{\npos.y += offset.y;\npos.y = (canvasSize.y * .5) + ((pos.y - (canvasSize.y * .5)) * sc);\npos.x = canvasSize.x * .5;\npos.z = 0.0;\npos.xyz *= scale;\n}\nelse if (int(i) % 5 == 0)\n{\npos.y += offset.y;\npos.y = (canvasSize.y * .5) + ((pos.y - (canvasSize.y * .5)) * sc);\npos.x = 50.0;\npos.z = 0.0;\npos.xyz *= scale;\n}\nelse if (int(i) % 4 == 0)\n{\npos.y += offset.y;\npos.y = (canvasSize.y * .5) + ((pos.y - (canvasSize.y * .5)) * sc);\npos.x = canvasSize.x - 50.0;\npos.z = 0.0;\npos.xyz *= scale;\n}\nelse if (int(i) % 3 == 0)\n{\npos.x += offset.x;\npos.x = (canvasSize.x * .5) + ((pos.x - (canvasSize.x * .5)) * sc);\npos.y = canvasSize.y * .5;\npos.z = 0.0;\npos.xyz *= scale;\n}\nelse if (int(i) % 2 == 0)\n{\npos.x += offset.x;\npos.x = (canvasSize.x * .5) + ((pos.x - (canvasSize.x * .5)) * sc);\npos.y = 50.0;\npos.z = 0.0;\npos.xyz *= scale;\n}\nelse\n{\npos.x += offset.x;\npos.x = (canvasSize.x * .5) + ((pos.x - (canvasSize.x * .5)) * sc);\npos.y = canvasSize.y - 50.0;\npos.z = 0.0;\npos.xyz *= scale;\n}\n}\nelse\n{\npos.xyz += offset;\npos.xyz *= scale;\n}\ngl_FragColor = vec4(pos.xyz, vel.w);\n}`,
                  cn
                )),
                (un.material.uniforms.time = { value: 0 }),
                (un.material.uniforms.frame = { value: 0 }),
                (un.material.uniforms.canvasSize = {
                  value: new Ye.Vector2(bn, zn),
                }),
                (un.material.uniforms.offset = { value: new Ye.Vector3() }),
                (un.material.uniforms.scale = { value: 1 }),
                (tn = nn.createTexture()),
                (an = nn.addVariable(
                  "textureAcc",
                  `\n${f}\n${u}\n${m}\n${d}\nuniform float maxAcc;\nuniform float time;\nuniform int frame;\nuniform int resetQuadrantIndex;\nuniform int isPreLoading;\nuniform int isPreview;\nuniform int isSameOwner;\nuniform vec4 unpairedShapes[10];\nuniform int numUnpaired;\nuniform float mergeTransition;\nuniform float sphereRadius;\nvoid main () \n{\nvec2 uv = gl_FragCoord.xy / resolution.xy;\nvec3 pos = texture2D(texturePosition, uv).xyz;\nvec4 vel = texture2D(textureVel, uv);\nvec4 targetPos = texture2D(texturePositionTarget, uv);\nfloat nPoints = resolution.x * resolution.y;\nfloat i = (gl_FragCoord.y * resolution.x) + gl_FragCoord.x;\nfloat type = floor(targetPos.w / 100.0);\nint iType = int(type);\ntargetPos.w -= type * 100.0;\nint colInd = int(floor((targetPos.w) / 10.0));\nvec3 acc;\nif (frame < 2)\n{\nacc = vec3(0);\n}\nelse\n{\nacc = (targetPos.xyz - pos) * .01;\nvec3 n = vec3(0.0); \nn.x = cnoise(vec3(pos * 0.004) + vec3(time * .1, 0.0, 0.0)) * 3.0;\nn.y = cnoise(vec3(pos * 0.0054) + vec3(time * .1, 0.0, 0.0)) * 3.0;\nfloat velStrength = length(vel.xyz);\nacc.xyz += n * pow(clamp(velStrength * 0.05, 0.0, 1.0), 3.0);\nif (isPreLoading != 1)\n{\nfloat r = hash12(uv * 123.4) * PI * 2.0;\nfor (int i = 0; i < numUnpaired; i++)\n{\nvec4 s = unpairedShapes[i];\nvec3 c = vec3(s.x, s.y, 0.0);\nfloat rad = s.z * 1.6;\nvec3 rep = vec3(cos(r), sin(r), 0.0);\nvec3 dir = vec3(pos.xy, 0.0) - c;\nfloat t = 1.0 - clamp(length(dir) / rad, 0.0, 1.0);\nfloat t2 = 1.0 - clamp(length(dir) / (rad * 1.8), 0.0, 1.0);\nif (t2 <= 0.0) continue;\nacc.xyz += rep * pow(t, 2.0) * 10.0;\nacc.xyz += n * t2 * 1.3;\n}\nif (iType == 1 && colInd < 1 && isSameOwner == 1)\n{\npos /= sphereRadius;\npos *= 400.0;\nn.x = cnoise(vec3(pos * 0.0012) + vec3(time * .1, 0.0, 0.0)) * 3.0;\nn.y = cnoise(vec3(pos * 0.0014) + vec3(time * .1, 0.0, 0.0)) * 3.0;\nn.z = cnoise(vec3(pos * 0.001) + vec3(time * .1, 0.0, 0.0)) * 3.0;\nfloat t = 1.0;\nt *= float(colInd+1) * .5;\nt *= mergeTransition;\nvec3 rep = vec3(cos(r * n.x), sin(r * n.y), sin(r * n.z));\nfloat n2 = cnoise(vec3(pos * 0.001) + vec3(time * .01, 0.0, 0.0));\nacc.xyz += rep * pow(n.z, 3.0) * n2 * 5.0 * t;\nacc.xyz += n * 2.0 * t;\n}\n}\n}\ngl_FragColor = vec4(acc.xyz, targetPos.w);\n}`,
                  tn
                )),
                (an.material.uniforms.time = { value: 0 }),
                (an.material.uniforms.frame = { value: 0 }),
                (an.material.uniforms.unpairedShapes = { value: Pt }),
                (an.material.uniforms.numUnpaired = { value: St }),
                (an.material.uniforms.isPreLoading = { value: lt }),
                (an.material.uniforms.isPreview = { value: Kt() ? 1 : 0 }),
                (an.material.uniforms.isSameOwner = { value: _t }),
                (an.material.uniforms.sphereRadius = { value: 200 }),
                (an.material.uniforms.mergeTransition = { value: Ft }),
                (on = nn.createTexture()),
                (rn = nn.addVariable(
                  "textureVel",
                  "\nuniform int resetQuadrantIndex;\nvoid main () {\nvec2 uv = gl_FragCoord.xy / resolution.xy;\nvec4 pos = texture2D(texturePosition, uv);\nvec4 acc = texture2D(textureAcc, uv);\nvec4 vel = texture2D(textureVel, uv);\nfloat nPoints = resolution.x * resolution.y;\nfloat i = (gl_FragCoord.y * resolution.x) + gl_FragCoord.x;\nvel.xyz += acc.xyz;\nvel.xyz *= .9;\ngl_FragColor = vec4(vel.xyz, acc.w);\n}",
                  on
                )),
                nn.setVariableDependencies(xn, [pn]),
                nn.setVariableDependencies(gn, [gn, xn]),
                nn.setVariableDependencies(pn, [pn, gn]),
                nn.setVariableDependencies(an, [ln, rn, dn]),
                nn.setVariableDependencies(rn, [ln, an, rn]),
                nn.setVariableDependencies(ln, [dn, ln, an, rn]),
                nn.setVariableDependencies(un, [dn, ln, an, rn]),
                nn.setVariableDependencies(dn, [ln, an, rn, pn]),
                nn.setVariableDependencies(wn, [dn])
              var e = nn.init()
              null !== e && console.error(e)
            })(),
            (function () {
              const e = new THREE.BufferGeometry()
              let n = []
              for (let e = 0; e < ut; e++) n.push(0, 0, 0)
              e.setAttribute(
                "position",
                new THREE.BufferAttribute(new Float32Array(n), 3)
              )
              let t = (function (e, n) {
                let t = ze.UniformsUtils.merge([
                    ze.ShaderLib.phong.uniforms,
                    { offset: new ze.Vector3() },
                    { sphereRadius: { value: 200 } },
                    { diffuse: { value: new ze.Color(16777215) } },
                    { time: { value: 0 } },
                    { scale: { value: 1 } },
                    { pixR: { value: 1 } },
                    { nX: { value: e } },
                    { nY: { value: n } },
                    { posTargetTex: { type: Pe } },
                    { posTex: { type: Pe } },
                    { accTex: { type: Pe } },
                    { velTex: { type: Pe } },
                    { colorTex: { type: Pe } },
                    { alpha: 1 },
                  ]),
                  a = ze.ShaderLib.points.vertexShader,
                  o = ze.ShaderLib.points.fragmentShader
                return (
                  (a = `\nuniform float time;\nattribute int indexAttr;\nuniform sampler2D posTargetTex;\nuniform sampler2D posTex;\nuniform sampler2D accTex;\nuniform sampler2D velTex;\nuniform sampler2D colorTex;\nuniform float scale;\nuniform float pixR;\nuniform vec3 offset;\nuniform float alpha;\nuniform float sphereRadius;\nvarying vec4 vPosition;\nvarying vec4 mvPosition;\nvarying vec4 color;\nvarying float vI;\nvarying vec4 vPosTarget;\nvarying vec3 vPos;\nvarying vec3 vAcc;\nvarying vec3 vVel;\nvarying float pointVisibilityRat;\n${u}\n${m}\n${d}\n${v}\n${g}\nvoid main() {\nint i = gl_VertexID;\nvI = float(i);\nfloat nX = ${e.toPrecision(5)};\nfloat nY = ${n.toPrecision(5)};\nvec2 uv = uvFromIndex(i, ivec2(int(nX), int(nY)));\nvPosTarget = texture2D(posTex, uv);\nvPos = texture2D(posTex, uv).xyz;\nvAcc = texture2D(accTex, uv).xyz;\nvVel = texture2D(velTex, uv).xyz;\ncolor = texture2D(colorTex, uv);\nfloat type = color.z;\nvec4 pos;\npos.xyz = vPos;\npos.w = 1.0;\nmvPosition = modelViewMatrix * pos;\ngl_Position = projectionMatrix * mvPosition;\ngl_PointSize = clamp(length(vVel) * .2, 2.0, 6.0);\ngl_PointSize = 3.1;\nfloat vis = color.a;\npointVisibilityRat = vis;\ngl_PointSize = .2 + pow(hash12(vec2(vI, vI)), 4.0) * 2.0;\nfloat h = hash12(vec2(vI + 132.3, uv.x + uv.y));\nif (h > .997)\n{\ngl_PointSize *= 1.5;\ncolor.a = .5;\nfloat h2 = hash12(vec2(uv.x, uv.y + vI));\nif (h2 > 0.999) gl_PointSize *= 2.0;\n}\nelse\n{\ncolor.a = .1;\n}\ncolor.b = (1.0 + sin(vI)) / 2.0;\ncolor.a *= 1.4 * vis * alpha;\ngl_PointSize *= 1.1 * vis;\ngl_PointSize *= 1.0 + pow(gl_PointSize * .1, 2.0);\ngl_PointSize *= sphereRadius * 0.005;\ngl_PointSize *= .5 * scale * pixR;\ncolor.a *= h < alpha ? 1.0 : 0.0;\n}`),
                  (o = o.replace(
                    "#include <common>",
                    `\n#include <common>\nuniform float time;\nvarying vec4 vPosition;\nvarying vec4 mvPosition;\nvarying vec4 color;\nvarying float type;\nvarying float indexRat;\nvarying float lengthRad;\nvarying float circRad;\nvarying float vI;\nvarying vec3 vPos;\nvarying vec3 vAcc;\nvarying vec3 vVel;\nvarying vec4 vPosTarget;\nvarying float pointVisibilityRat;\n${u}\n${d}\n`
                  )),
                  (o = o.replace(
                    "#include <fog_fragment>",
                    "\ngl_FragColor = color;\nfloat a = 1.0 - pow(length(gl_PointCoord - vec2(.5, .5)) / .5, 100.0);\nif (a <= 0.0 || color.a <= .0) discard;\n#include <fog_fragment>\n"
                  )),
                  new ze.ShaderMaterial({
                    uniforms: t,
                    vertexShader: a,
                    side: ze.DoubleSide,
                    wireframe: !1,
                    fragmentShader: o,
                    lights: !0,
                    fog: !0,
                    name: "custom-material",
                    depthWrite: !0,
                    depthTest: !0,
                    transparent: !0,
                    blending: THREE.AdditiveBlending,
                  })
                )
              })(mt, dt)
              new THREE.PointsMaterial({ color: 16777215, size: 0.1 }),
                (Un = new THREE.Points(e, t)),
                Dn.add(Un)
            })(),
            (function () {
              const e = new THREE.BufferGeometry()
              let n = []
              for (let e = 0; e < 15e3; e++) n.push(0, 0, 0)
              e.setAttribute(
                "position",
                new THREE.BufferAttribute(new Float32Array(n), 3)
              )
              let t = (function (e, n, t, a, o) {
                let r = `\nvarying float vIndex;\nvarying float vDistance;\nvarying vec4 vColor;\nconst float nX = ${e.toPrecision(5)};\nconst float nY = ${n.toPrecision(5)};\nconst float n = nX * nY;\nuniform sampler2D posTex;\nuniform sampler2D velTex;\nuniform sampler2D colorTex;\nuniform float sphereRadius;\nvec2 uvFromIndex (int i)\n{\nfloat y = floor((float(i) / nX) + 0.0001);\nfloat x = float(i) - (y * nX);\nvec2 uv = vec2(x, y) / vec2(nX, nY);\nreturn uv;\n}\nvec3 posFromIndex (int i)\n{\nvec2 uv = uvFromIndex(i);\nvec3 pos = texture2D(posTex, uv).xyz;\nreturn pos;\n}\nvoid main ()\n{\nint i = gl_VertexID;\nint index;\nint stride = 1;\nint i2 = i * stride;\ni2 += int(floor(float(i)/100.0) * 10000.0);\nvec2 pUv = uvFromIndex(i2-stride);\nvec3 pPos = texture2D(posTex, pUv).xyz;\nvec3 pVel = texture2D(velTex, pUv).xyz;\nvec3 nPos = pPos + (pVel*1.0);\nfloat type = texture2D(colorTex, uvFromIndex(index)).z;\nvec3 pos;\nfloat d;\nint off = 30;\noff = int(2.0 + (1.0 + sin(float(i) * 0.001) / 2.0) * 8.0);\noff = 5;\nif ((i+1) % 2 == 0)\n{\nindex = i2+off;\nnPos = posFromIndex(index);\ntype = texture2D(colorTex, uvFromIndex(index)).z;\nfloat maxLength = sphereRadius *.5;\nif (type >= 2.0) maxLength = 0.0;\npos = nPos;\nd = abs(distance(pPos, pos));\nif (d > maxLength)\n{\npos = pPos;\nindex = i2-stride;\n}\n}\nelse\n{\nindex = i2;\npos = posFromIndex(index);\nd = abs(distance(pos, posFromIndex(i2+off)));\n}\nvDistance = d;\nvec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);\ngl_Position = projectionMatrix * mvPosition;\nvIndex = float(index);\nvec4 c = texture2D(colorTex, uvFromIndex(index));\nvColor = vec4(c.rg, 0.0, c.a - (.2 * type));\nvColor.a *= clamp(sphereRadius / 200.0, .1, 1.0);\n}\n`
                return new THREE.ShaderMaterial({
                  uniforms: {
                    time: { value: 1 },
                    posTex: { value: t },
                    velTex: { value: a },
                    colorTex: { value: o },
                    alpha: { value: 0 },
                    sphereRadius: { value: 200 },
                  },
                  vertexShader: r,
                  fragmentShader:
                    "\nvarying float vIndex;\nvarying float vDistance;\nvarying vec4 vColor;\nuniform float alpha;\nvoid main ()\n{\ngl_FragColor = vec4(vColor.rgb, vColor.a * .2 * alpha);\n}\n",
                  transparent: !0,
                  depthWrite: !1,
                  depthTest: !1,
                  transparent: !0,
                  blending: THREE.AdditiveBlending,
                })
              })(
                mt,
                dt,
                nn.getCurrentRenderTarget(un).texture,
                nn.getCurrentRenderTarget(rn).texture,
                nn.getCurrentRenderTarget(wn).texture
              )
              ;(qn = new THREE.LineSegments(e, t)), Dn.add(qn)
            })(),
            (function () {
              var e = Ye.ShaderLib.basic.vertexShader,
                n = (function (e, n, t, a = !1) {
                  let o = `gl_FragColor.a = clamp(${n.toPrecision(5)} + ceil(brightness), 0.0, 1.0);`
                  n >= 1 && (o = "")
                  let r =
                    "\nint i = topWindow == 0 ? 1 : 0;\nvec4 r = instanceShape[i] * pixR;\nvec4 colors[] = colors0;\nif (i == 1) colors = colors1;\nif (fc.x >= r.x && \nfc.y <= (height * pixR) - r.y && \nfc.x <= (r.x + r.z) && \nfc.y >= (height * pixR) - (r.y + r.w))\n{\nbg = colors[0].rgb;\nc1 = colors[1].rgb;\nc2 = colors[2].rgb;\n}\ni = topWindow == 0 ? 0 : 1;\nr = instanceShape[i] * pixR;\ncolors = colors0;\nif (i == 1) colors = colors1;\nif (fc.x >= r.x && \nfc.y <= (height * pixR) - r.y && \nfc.x <= (r.x + r.z) && \nfc.y >= (height * pixR) - (r.y + r.w))\n{\nbg = colors[0].rgb;\nc1 = colors[1].rgb;\nc2 = colors[2].rgb;\n}\n"
                  return (
                    a || (r = ""),
                    `\nuniform sampler2D map;\nuniform sampler2D debugMap;\nuniform float time;\nuniform float width;\nuniform float height;\nuniform vec2 innerSize;\nuniform float noiseStrength;\nuniform vec4 colors0[3];\nuniform vec4 colors1[3];\nuniform vec4 unpairedColors[10];\nuniform vec4 unpairedShapes[10];\nuniform vec4 instanceShape[2];\nuniform vec4 instancevis[2];\nuniform int numUnpaired;\nuniform int topWindow;\nuniform vec3 offset;\n\nvec3 rgb2hsv(vec3 c)\n{\nvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\nvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\nvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\nfloat d = q.x - min(q.w, q.y);\nfloat e = 1.0e-10;\nreturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n\nvec3 hsv2rgb(vec3 c)\n{\nvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\nreturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat random( vec2 p )\n{\nvec2 K1 = vec2(\n23.14069263277926,\n2.665144142690225\n);\nreturn fract( cos( dot(p,K1) ) * 12345.6789 );\n}\nfloat rand(vec2 co){\nreturn fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat sSin(float x)\n{\nreturn (1.0 + sin(x)) / 2.0;\n}\nfloat hash12(vec2 p)\n{\nvec3 p3  = fract(vec3(p.xyx) * .1031);\np3 += dot(p3, p3.yzx + 33.33);\nreturn fract((p3.x + p3.y) * p3.z);\n}\nvoid main ()\n{\nfloat pixR = ${e.toPrecision(6)};\nvec2 fc = gl_FragCoord.xy;\nvec2 uv = fc / vec2(width * pixR, height * pixR);\nvec4 c = texture2D( map, uv);\nfloat brightness = (c.r + c.g + c.b) / 3.0;\nfloat brig = ${t ? (2).toPrecision(5) : 1.4};\nfloat cont = 1.0;\nfloat max = ${t ? (1.7).toPrecision(5) : 1.1};\nc.rgb = clamp(pow(c.rgb, vec3(cont)) * brig, vec3(0.0), vec3(max));\nfloat c1Rat = c.r;\nfloat c2Rat = c.g;\nvec3 bg = colors0[0].rgb;\nvec3 c1 = colors0[1].rgb;\nvec3 c2 = colors0[2].rgb;\n${r}\nfloat bgBright = (bg.r + bg.g + bg.b) / 3.0;\nfloat c1Bright = (c1.r + c1.g + c1.b) / 3.0;\nfloat c2Bright = (c2.r + c2.g + c2.b) / 3.0;\nfloat bright = 1.3;\nc1Rat *= bright;\nc2Rat *= bright;\nc1Rat *= 1.8 - c1Bright;\nc2Rat *= 1.8 - c2Bright;\nfor (int i = 0; i < numUnpaired; i++)\n{\nvec4 s = unpairedShapes[i];\ns.xyz += offset;\ns.y = height - s.y;\ns *= pixR;\nvec3 center = vec3(s.x, s.y, 0.0);\nfloat rad = s.z * pixR;\nvec3 dir = vec3(fc, 0.0) - center;\nfloat t = 1.0 - pow(clamp(length(dir) / rad, 0.0, 1.0), 2.0);\nif (t <= 0.0) continue;\nvec3 c3 = unpairedColors[i].rgb;\nc1 = mix(c1, c3, t);\nc2 = mix(c2, c3, t);\n}\nvec3 c12 = rgb2hsv(c1);\nc12.r += sin(c.b * 7.0) * .05;\nfloat satInc = sin(c.b * 8.0) * .3;\nc12.g += satInc * c12.g;\nc12.b -= satInc;\nc12 = clamp(c12, 0.0, 1.0);\nc12 = hsv2rgb(c12);\nc1 = mix(c1, c12, c.b);\nvec3 c22 = rgb2hsv(c2);\nc22.r += sin(c.b * 7.0) * .05;\nc22.g += satInc * c22.g;\nc22.b -= satInc;\nc22 = clamp(c22, 0.0, 1.0);\nc22 = hsv2rgb(c22);\nc2 = mix(c2, c22, c.b);\nbg = clamp(mix(bg, c1, c1Rat), 0.0, 1.0);\nbg = clamp(mix(bg, c2, c2Rat), 0.0, 1.0);\nbg.rgb += vec3(c.b * .1);\nc.rgb = bg;\ngl_FragColor = c;\nfloat bri = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;\nfloat n = hash12(gl_FragCoord.xy + time);\ngl_FragColor = gl_FragColor * .95 + pow(vec4(n, n, n, 1.0), vec4(1.0)) * .08 * noiseStrength;\ngl_FragColor += pow(vec4(n, n, n, 1.0), vec4(1.0)) * ((.013 + (bri * .12))) * noiseStrength;\ngl_FragColor = clamp(gl_FragColor, vec4(0.0), vec4(1.0));\n${o}\n}`
                  )
                })(Tn, ht, Kt(), Ht),
                t = Ye.UniformsUtils.merge([
                  Ye.ShaderLib.basic.uniforms,
                  { time: { value: 0 } },
                  { width: { value: bn } },
                  { height: { value: zn } },
                  { noiseStrength: { value: 1 } },
                  { colors0: { value: Wn } },
                  { colors1: { value: kn } },
                  { unpairedShapes: { value: Pt } },
                  { unpairedColors: Rt },
                  { numUnpaired: { value: St } },
                  { offset: { value: new Ye.Vector3(0, 0, 0) } },
                  {
                    innerSize: {
                      value: new Ye.Vector2(
                        window.innerWidth * it,
                        window.innerHeight * it
                      ),
                    },
                  },
                  {
                    instanceShape: {
                      value: { value: [new Ye.Vector4(), new Ye.Vector4()] },
                    },
                  },
                  { instanceVis: { value: [0, 0] } },
                  { topWindow: { value: $t } },
                ])
              ;(An = new Ye.ShaderMaterial({
                uniforms: t,
                vertexShader: e,
                fragmentShader: n,
                name: "filter-material",
              })),
                (Fn = new Ye.Scene()),
                (Fn.background = new Ye.Color(0, 0, 0)),
                (Mn = new Ye.OrthographicCamera(0, bn, 0, zn, -1e4, 1e4)),
                (Mn.position.z = 1),
                (Ln = new Ye.Mesh(new Ye.PlaneGeometry(1, 1), An)),
                (Ln.scale.x = bn),
                (Ln.scale.y = zn),
                Fn.add(Ln),
                (Xn = new Ye.Scene()),
                (Xn.background = new Ye.Color(1, 0, 0)),
                (Gn = new Ye.Object3D())
              let a = 1 / 3,
                o = 0.5,
                r = []
              r.push(nn.getCurrentRenderTarget(dn).texture),
                r.push(nn.getCurrentRenderTarget(rn).texture),
                r.push(nn.getCurrentRenderTarget(an).texture),
                r.push(nn.getCurrentRenderTarget(ln).texture),
                (Bn = new Ye.WebGLRenderTarget(bn * Tn, zn * Tn, {
                  depthBuffer: !0,
                  format: THREE.RGBAFormat,
                  colorSpace: THREE.LinearSRGBColorSpace,
                }))
              let i = 0
              for (let e = 0; e < 2; e++)
                for (let n = 0; n < 3 && !(i >= r.length); n++) {
                  let t = new Ye.Mesh(
                    new Ye.PlaneGeometry(a, o),
                    new Ye.MeshBasicMaterial()
                  )
                  0 == i
                    ? (t.material.color = new Ye.Color(15, 15, 15, 0))
                    : 1 == i && (t.material.color = new Ye.Color(5, 5, 5, 0)),
                    (t.position.x = -0.5 * (1 - a) + a * n),
                    (t.position.y = 0.5 * (1 - o) - o * e),
                    (t.material.map = r[i]),
                    (t.material.map.offset = new Ye.Vector2((1 / mt) * 2, 0)),
                    Gn.add(t),
                    i++
                }
              ;(Gn.position.x = -0.5),
                (Gn.position.y = 0.5),
                (Gn.scale.x = bn),
                (Gn.scale.y = zn),
                Xn.add(Gn)
            })(),
            je.fps &&
              (function () {
                let e = document.createElement("div")
                e.setAttribute("id", "stats"),
                  (Nn = document.createElement("p")),
                  (Nn.innerText = "fps: 60"),
                  (e.style.position = "absolute"),
                  (e.style.top = e.style.left = "10px"),
                  (e.style.color = "#333333"),
                  e.appendChild(Nn),
                  document.body.appendChild(e)
              })(),
            na(),
            ea(),
            qt(),
            Jt(),
            Zt(),
            window.addEventListener("resize", e => {
              na()
            }),
            Ht ||
              (Wt(),
              (window.screen.onchange = () => {
                let e = screen.isExtended
                !yt && e
                  ? (console.log("plugged screen in"), Wt())
                  : yt && !e
                    ? (console.log("plugged screen out"), Wt())
                    : console.log("window changed screen"),
                  (yt = e)
              })),
            (wt = !0)
        },
        480 + 40 * Math.random()
      )
  }
  async function Wt() {
    if (window.screen.isExtended) {
      async function e() {
        return (
          console.log("get permission"),
          new Promise(async e => {
            try {
              let n = await navigator.permissions.query({
                name: "window-management",
              })
              if ("granted" == n.state) {
                console.log("permission granted"),
                  e(await window.getScreenDetails())
              } else if ("prompt" == n.state) {
                console.log("prompt"), e(await window.getScreenDetails())
              } else console.log("permission denied"), e(-1)
            } catch (n) {
              console.log("error"), console.log(n), e(null)
            }
          })
        )
      }
      return (
        console.log("screen is extended"),
        (xt.w = screen.availWidth),
        (xt.h = screen.availHeight),
        new Promise(async n => {
          let t,
            a = await e()
          function o() {
            t && document.body.removeChild(t),
              -1 != a &&
                null != a &&
                (function (e) {
                  let n = { x: Number.MAX_VALUE, y: Number.MAX_VALUE },
                    t = { x: Number.MIN_VALUE, y: Number.MIN_VALUE }
                  e.screens.forEach(e => {
                    let a = { x: e.left, y: e.top },
                      o = { x: e.left + e.availWidth, y: e.availHeight }
                    a.x < n.x && (n.x = a.x),
                      a.y < n.y && (n.y = a.y),
                      o.x > t.x && (t.x = o.x),
                      o.y > t.y && (t.y = o.y)
                  }),
                    (xt = { x: n.x, y: n.y, w: t.x - n.x, h: t.y - n.y }),
                    na(),
                    qt(!1)
                })(a),
              console.log(a),
              n(a)
          }
          null == a
            ? (console.log("ask for permission"),
              (t = (function () {
                const e = document.createElement("div")
                e.innerHTML =
                  "<p>It seems you have multiple displays connected to your computer.</br>Click anywhere and select Allow for optimal viewing experience!</p>"
                let n = e.style
                return (
                  (n.backgroundColor = "rgba(0, 0, 0, .7)"),
                  (n.position = "absolute"),
                  (n.display = "flex"),
                  (n.justifyContent = "center"),
                  (n.top = n.left = n.right = n.bottom = 0),
                  (n.alignItems = "center"),
                  (n.textAlign = "center"),
                  (n.color = "FFFFFF"),
                  (n.fontFamily = "Courier New"),
                  (n.fontSize = "12px"),
                  (n.textTransform = "uppercase"),
                  document.body.appendChild(e),
                  e
                )
              })()),
              t.addEventListener("click", async () => {
                ;(a = await e()), o()
              }))
            : o()
        })
      )
    }
    return (
      (xt.w = screen.availWidth), (xt.h = screen.availHeight), na(), qt(!1), 1
    )
  }
  function kt(e) {
    "isPreLoading" == e.key
      ? (e.id == Tt.id && (Tt.isPreLoading = e.value),
        e.id == bt.id && (bt.isPreLoading = e.value),
        Jt())
      : "isSphere" == e.key && Ut()
  }
  function Nt() {
    let e = On.getWindows(),
      n = [],
      t = []
    function a(e, n) {
      null != n
        ? ((e.id = n.id),
          (e.shape = new Ye.Vector4(
            n.shape.x,
            n.shape.y,
            n.shape.w,
            n.shape.h
          )),
          (e.walletsOwner = n.metaData.walletsOwner),
          (e.isPreLoading = n.metaData.isPreLoading),
          (e.resolvedIteration = n.metaData.resolvedIteration))
        : ((e.visibilityTarget = 0),
          (e.id = -1),
          (e.walletsOwner = []),
          (e.isPreLoading = 1))
    }
    ;(zt = []),
      e.forEach(e => {
        e.metaData.resolvedIteration == D.resolved()
          ? 0 == e.metaData.instanceIndex
            ? n.push(e)
            : 1 == e.metaData.instanceIndex && t.push(e)
          : zt.push(e)
      }),
      (St = zt.length),
      a(Tt, n[0]),
      a(bt, t[0]),
      (function () {
        let e = !1
        for (let n = 0; n < Tt.walletsOwner.length; n++)
          bt.walletsOwner.includes(Tt.walletsOwner[n]) && (e = !0)
        _t = e ? 1 : 0
      })(),
      Ut(),
      -1 != Tt.id && bt.id
    let o = On.getThisWindowID() == Tt.id || On.getThisWindowID() == bt.id
    On.getThisWindowData().metaData.isSphere != o &&
      On.setMetaData("isSphere", o)
  }
  function Ut() {
    ;(Pt = []), (Rt = [])
    let e = On ? On.getWindows() : []
    for (let n = 0; n < e.length; n++) {
      let t = e[n]
      if (t.metaData.isSphere && t.id != Tt.id && t.id != bt.id) {
        let n = t.shape.h
        for (let a = 0; a < e.length; a++) {
          let o = e[a]
          o.metaData.isSphere &&
            o.metaData.resolvedIteration == t.metaData.resolvedIteration &&
            o.metaData.instanceIndex != t.metaData.instanceIndex &&
            o.shape.h < n &&
            (n = o.shape.h)
        }
        let a = Qt(n),
          o = new Ye.Vector4(
            t.shape.x + 0.5 * t.shape.w,
            t.shape.y + 0.5 * t.shape.h,
            a,
            0
          ),
          r = pe(t.metaData.resolvedIteration),
          i = t.metaData.instanceIndex,
          s = r[i][i + 1],
          l = new THREE.Color(s)
        Rt.push(l), Pt.push(o)
      }
    }
    St = Pt.length
    for (let e = Pt.length; e < 10; e++)
      Pt.push(new Ye.Vector4(-1, -1, -1, -1)), Rt.push(new Ye.Color())
  }
  function qt(e = !0) {
    ;(Rn = { x: -window.screenX + xt.x, y: -window.screenY + xt.y }),
      e || (Pn = Rn)
  }
  function Xt(e) {
    let n = []
    return (
      e.forEach(e => {
        let t = new THREE.Color(e)
        n.push(t)
      }),
      n
    )
  }
  function Gt(e, n, t) {
    let a = new Float32Array(4 * (n * t))
    for (let n = 0; n < e.length; n++) {
      const t = 4 * n
      ;(a[t] = e[n].x), (a[t + 1] = e[n].y), (a[t + 2] = e[n].z), (a[t + 3] = 0)
    }
    let o = new THREE.DataTexture(a, n, t, THREE.RGBAFormat, THREE.FloatType)
    return (o.needsUpdate = !0), o
  }
  function jt() {
    return new Date().getTime()
  }
  function Yt() {
    return (jt() - en) / 1e3
  }
  function Kt() {
    return $fx.isPreview || Qe
  }
  function Jt() {
    let e = 0 == V ? bt : Tt
    Tt.isPreLoading || bt.isPreLoading || Ht || (e.visibilityTarget = 1)
  }
  function Qt(e) {
    let n = a(e, 400, 3e3, 0.3, 0.1)
    return Kt() && (n = 0.26), t(e * n, 100, 500)
  }
  function Zt(e) {
    let n,
      t = 0 == V ? Tt : bt
    if ((Ht || (t.visibilityTarget = 1), !st)) {
      if (Kt()) {
        let e = 1 / 60
        console.log(
          "is preview, internalTime: " + Vn + ", frame: " + ot,
          ", delta: " + e,
          "isPreLoading",
          lt
        ),
          (Vn += e)
      } else Vn = Yt()
      nn.compute()
    }
    if ((Nn && (Nn.innerText = "fps: " + $n + ": " + ot), jn.isDone() && !It)) {
      ;(lt = 0),
        (t.isPreLoading = 0),
        (ct = ot),
        On && On.setMetaData("isPreLoading", lt),
        Jt()
      let e = jn.getPolylineVertices(),
        n = Math.ceil(Math.sqrt(e.length))
      ;(Yn = Gt(e, n, n)),
        (Ct = new Ye.Vector2(n, n)),
        (Vt = e.length),
        (It = !0)
    } else (!pt && jn.isDone()) || jn.compute(Vn)
    Ht && (Tt.isPreLoading = bt.isPreLoading = lt)
    let a = 1e7
    if (-1 != Tt.id && -1 != bt.id) {
      n = Tt.shape.w < bt.shape.w ? Tt.shape.w : bt.shape.w
      let e = new Ye.Vector2(
          Tt.shape.x + 0.5 * Tt.shape.z,
          Tt.shape.y + 0.5 * Tt.shape.w
        ),
        t = new Ye.Vector2(
          bt.shape.x + 0.5 * bt.shape.z,
          bt.shape.y + 0.5 * bt.shape.w
        )
      a = e.distanceTo(t)
    } else n = t.shape.w
    let o = Qt(n)
    Dn.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), 0 * Ze.y),
      Dn.rotateOnWorldAxis(new THREE.Vector3(1, 0, 0), 0 * Ze.x)
    let r = new Ye.Vector3(Pn.x - xt.x, Pn.y - xt.y, 0)
    Ht && (r = new Ye.Vector3())
    let i = ln.material.uniforms,
      s = un.material.uniforms
    ;(i.time = { value: Vn }),
      (i.frame = { value: ot }),
      (i.canvasSize = { value: new Ye.Vector2(bn, zn) }),
      (i.scale = { value: it }),
      (i.offset = { value: r }),
      (i.isPreLoading = { value: lt }),
      (i.isPreview = { value: Kt() ? 1 : 0 }),
      (i.preLoadingStoppedAtFrame = { value: ct }),
      (s.time = { value: Vn }),
      (s.frame = { value: ot }),
      (s.canvasSize = { value: new Ye.Vector2(bn, zn) }),
      (s.scale = { value: it }),
      (s.offset = { value: r })
    let l = [Tt.shape, bt.shape],
      c = [Tt.visibility, bt.visibility]
    ;(dn.material.uniforms.time = { value: Vn }),
      (dn.material.uniforms.sphereRadius = { value: o }),
      (dn.material.uniforms.rotationTime = { value: Dt }),
      (dn.material.uniforms.frame = { value: ot }),
      (dn.material.uniforms.instanceShape = { value: l }),
      (dn.material.uniforms.instanceVis = { value: c }),
      (dn.material.uniforms.numRdPolyVerts = { value: Vt }),
      (dn.material.uniforms.isPreLoading = { value: lt }),
      (dn.material.uniforms.isSameOwner = { value: _t }),
      (dn.material.uniforms.instanceIndex = { value: V }),
      (dn.material.uniforms.rdPolyTex = { value: Yn }),
      (dn.material.uniforms.unpairedShapes = { value: Pt }),
      (dn.material.uniforms.numUnpaired = { value: St }),
      (dn.material.uniforms.mergeTransition = { value: Ft }),
      (dn.material.uniforms.diagramVisibility = { value: Lt }),
      be.injectUniforms(dn.material.uniforms),
      (wn.material.uniforms.mergeTransition = { value: Ft }),
      (wn.material.uniforms.isSameOwner = { value: _t }),
      (pn.material.uniforms.time = { value: Vn }),
      (pn.material.uniforms.frame = { value: ot }),
      (gn.material.uniforms.time = { value: Vn }),
      (gn.material.uniforms.frame = { value: ot }),
      (xn.material.uniforms.time = { value: Vn }),
      (xn.material.uniforms.frame = { value: ot }),
      (an.material.uniforms.time = { value: Vn }),
      (an.material.uniforms.frame = { value: ot }),
      (an.material.uniforms.unpairedShapes = { value: Pt }),
      (an.material.uniforms.numUnpaired = { value: St }),
      (an.material.uniforms.isPreLoading = { value: lt }),
      (an.material.uniforms.isPreview = { value: Kt() ? 1 : 0 }),
      (an.material.uniforms.isSameOwner = { value: _t }),
      (an.material.uniforms.sphereRadius = { value: o }),
      (an.material.uniforms.mergeTransition = { value: Ft })
    let u = Tt.visibilityTarget > Tt.visibility ? 0.01 : 0.1
    ;(Tt.visibility += (Tt.visibilityTarget - Tt.visibility) * u),
      (u = bt.visibilityTarget > bt.visibility ? 0.01 : 0.1),
      (bt.visibility += (bt.visibilityTarget - bt.visibility) * u),
      (u = 0.05),
      (Pn.x = Pn.x + (Rn.x - Pn.x) * u),
      (Pn.y = Pn.y + (Rn.y - Pn.y) * u),
      (u = 0.1),
      (Mt = a < 0.7 * o ? 1 : 0),
      (Ft += (Mt - Ft) * u),
      (u = 0.1),
      (At = !_t || Tt.isPreLoading || bt.isPreLoading ? 0 : 1),
      (Lt += (At - Lt) * u),
      Pn.x,
      Pn.y,
      Kt()
        ? (gt = 1)
        : lt && gt < 0.25
          ? (gt += 0.01)
          : !lt && gt < 1 && (gt += 0.02),
      (Un.material.uniforms.time = { value: Vn }),
      (Un.material.uniforms.posTargetTex = {
        value: nn.getCurrentRenderTarget(dn).texture,
      }),
      (Un.material.uniforms.colorTex = {
        value: nn.getCurrentRenderTarget(wn).texture,
      }),
      (Un.material.uniforms.posTex = {
        value: nn.getCurrentRenderTarget(un).texture,
      }),
      (Un.material.uniforms.velTex = {
        value: nn.getCurrentRenderTarget(rn).texture,
      }),
      (Un.material.uniforms.accTex = {
        value: nn.getCurrentRenderTarget(an).texture,
      }),
      (Un.material.uniforms.scale = { value: it }),
      (Un.material.uniforms.pixR = { value: Tn }),
      (Un.material.uniforms.offset = { value: r }),
      (Un.material.uniforms.alpha = { value: gt }),
      (Un.material.uniforms.sphereRadius = { value: o }),
      (qn.material.uniforms.alpha = { value: gt }),
      (qn.material.uniforms.sphereRadius = { value: o })
    if (
      (0 == lt &&
        ot > ct + 400 &&
        !Sn &&
        (Sn || (console.log("trigger preview"), $fx.preview(), (Sn = !0))),
      (Kt() && -1 != ct && ot > ct + 290) || (!Kt() && !st))
    ) {
      Kt() && console.log("rendering")
      {
        let e = Cn.getRenderTarget()
        Cn.setRenderTarget(Bn),
          Cn.render(In, En),
          (Ln.material.uniforms.map.value = Bn.texture),
          (Ln.material.uniforms.time.value = _n),
          (Ln.material.uniforms.width.value = bn),
          (Ln.material.uniforms.height.value = zn),
          (Ln.material.uniforms.noiseStrength.value = vt ? 0.6 : 0.8),
          (Ln.material.uniforms.unpairedShapes.value = Pt),
          (Ln.material.uniforms.unpairedColors.value = Rt),
          (Ln.material.uniforms.numUnpaired.value = St),
          (Ln.material.uniforms.offset = { value: r }),
          (Ln.material.uniforms.innerSize = {
            value: new Ye.Vector2(window.innerWidth * it, Je.innerHeight * it),
          }),
          (Ln.material.uniforms.instanceShape = { value: l }),
          (Ln.material.uniforms.instanceVis = { value: c }),
          (Ln.material.uniforms.topWindow = { value: $t }),
          Cn.setRenderTarget(e),
          ft ? Cn.render(Xn, Mn) : Cn.render(Fn, Mn)
      }
    }
    st || ot++
  }
  function ea() {
    var n = jt()
    let t = (n - at) / 1e3
    function a() {
      requestAnimationFrame(ea), rt++
    }
    ;($n = 1 / t),
      (_n += t),
      (at = n),
      Ht ||
        (On.update(),
        On.getWindows().forEach(e => {
          e.id == Tt.id
            ? (Tt.shape = new THREE.Vector4(
                e.shape.x,
                e.shape.y,
                e.shape.w,
                e.shape.h
              ))
            : e.id == bt.id &&
              (bt.shape = new THREE.Vector4(
                e.shape.x,
                e.shape.y,
                e.shape.w,
                e.shape.h
              ))
        }),
        Ut()),
      rt >= 30
        ? (($n > 80 && rt % 2 == 0) || Zt(),
          vt
            ? Cn.domElement.toBlob(function (n) {
                ;(vt = !1),
                  e(n, "face_" + ot.toString().padStart(3, "0") + ".png"),
                  a()
              })
            : a())
        : 29 == rt
          ? ((Hn = $n), console.log("measuredFps", Hn), a())
          : a()
  }
  function na() {
    let e = 1
    if (On) {
      let n = On.numWindows()
      n > e && (e = n)
    }
    let n = screen.availWidth,
      t = screen.availHeight,
      a = Math.ceil(n / e),
      o = Math.ceil(t / e),
      r = window.innerWidth,
      i = window.innerHeight,
      s = Math.ceil(r / a) * a,
      l = Math.ceil(i / o) * o
    Kt() &&
      ((s = r),
      (l = i),
      console.log("preview width", s, "height", l, "pixR", Tn, "scale", it)),
      (s *= it),
      (l *= it),
      (bn == s && zn == l) ||
        ((bn = s),
        (zn = l),
        console.log("perform resize: ", bn, zn, e),
        (En.left = En.top = 0),
        (En.right = bn),
        (En.bottom = zn),
        En.updateProjectionMatrix(),
        Cn.setSize(bn, zn, !1),
        (Cn.domElement.style.width = bn / it + "px"),
        (Cn.domElement.style.height = zn / it + "px"),
        (Mn.left = Mn.bottom = 0),
        (Mn.right = bn),
        (Mn.top = zn),
        Mn.updateProjectionMatrix(),
        Bn.setSize(bn * Tn, zn * Tn),
        (Ln.scale.x = bn),
        (Ln.scale.y = zn),
        (Ln.position.x = 0.5 * bn),
        (Ln.position.y = 0.5 * zn),
        (Gn.scale.x = bn),
        (Gn.scale.y = zn))
  }
  Tn <= 1 && ((Ot = !0), (it = 2), (bn *= it), (zn *= it)),
    document.addEventListener("visibilitychange", () => {
      "hidden" == document.visibilityState || wt || Bt()
    }),
    (window.onload = () => {
      "hidden" != document.visibilityState && Bt()
    }),
    document.addEventListener("keydown", e => {
      "Space" == e.code
        ? (st = !st)
        : "KeyD" == e.code
          ? ((ft = !ft), console.log(ft))
          : "KeyS" == e.code
            ? (vt = !0)
            : "KeyW" == e.code || e.code
    })
  let ta = (function () {
    let e = ge,
      n = ["a", "b", "c"],
      t = "0"
    0 == e.motionType0
      ? (t = e.spheres[0].pm.type.toString() + "-" + e.spheres[1].pm.type)
      : 2 == e.motionType0 && (t = e.rd.type)
    let a = "0"
    0 == e.motionType1
      ? (a = e.spheres[0].pm.type.toString() + "-" + e.spheres[1].pm.type)
      : 2 == e.motionType1 && (a = e.rd.type)
    let o = n[e.motionType0] + t,
      r = n[e.motionType1] + a
    var i
    return {
      "color scheme": e.schemeIndex,
      "inverted pair": ((i = e.schemeInverted), i ? "yes" : "no"),
      "motion 0": o,
      "motion 1": r,
      "connection twists": e.connectionTwists / 2,
      "main type": 1 == e.mainType ? "icosahedron" : "sphere",
      "core type": ["sphere", "icosahedron", "cube", "octahedron"][
        e.babyTwinType
      ],
    }
  })()
  $fx.features(ta),
    console.log("DETAILED FEATURES -------------------------"),
    console.log(JSON.stringify(ge, null, 2)),
    console.log("----------------------------------"),
    console.log("FEATURES -------------------------")
  for (const [e, n] of Object.entries(ta)) console.log(`${e}: ${n}`)
  console.log("----------------------------------")
})()
